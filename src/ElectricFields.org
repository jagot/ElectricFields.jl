#+TITLE: ElectricFields.jl
#+AUTHOR: Stefanos Carlström
#+EMAIL: stefanos.carlstrom@gmail.com

#+PROPERTY: header-args:julia :session *julia-ElectricFields*

The idea of this package is to provide an interface between the
reality and calculations. In the calculations, it is useful to
represent fields in terms of cycles of a /fundamental/ frequency,
which yields a timebase. E.g. one might use laser pulses of 800 nm, in
an experiment, which has a period time of about 2.66 fs. It is,
however, easier to calculate in normalized time, and relate all other
quantities of interest (such as ionization potential, &c) to this time
scale.

The package provides a simple DSL that requires just a handful of
parameters, that can be given in /any/ unit system (thanks to
[[https://github.com/ajkeller34/Unitful.jl][Unitful.jl]]). Different fields can be combined in any way that is
physically reasonable, to recreate complicated experimental
situations. Everything can then be converted to normalized time, for
use in calculations.

#+BEGIN_SRC julia
  using Unitful
  using Parameters
  import Base: show
#+END_SRC

#+RESULTS:
: nothing

* Todo
  - [X] Automatic calculation of time span from envelope
  - [ ] Delayed fields
  - [ ] Field arithmetic
  - [ ] Common time-base
  - [ ] Temporal discretization
  - [ ] Tests

* Units
  #+BEGIN_SRC julia
    # Unit arithmetic is performed "outside" of @u_str, to ensure type
    # stability and allow precompilation
    base_units = Dict{Symbol,Unitful.FreeUnits}(
        :λ => u"nm",
        :I₀ => u"W"/u"cm"^2,
        :E₀ => u"V"/u"m",
        :τ => u"fs",
        :σ => u"fs",
        :σ′ => u"fs",
        :σmax => NoUnits,
        :σ′max => NoUnits,
        :tmax => u"fs",
        :Tmax => NoUnits,
        :T => u"fs",
        :f => u"THz",
        :ν => u"cm"^-1,
        :ω => u"Trad"/u"s",
        :Uₚ => u"eV"
    )

    function get_unitful_quantity(field_params::Dict{Symbol,Any}, sym::Symbol)
        v = field_params[sym]
        typeof(v) <: Quantity || sym ∉ keys(base_units) ? v : v*base_units[sym]
    end

    function set_base_units(unit_specs::Dict{Symbol, Any})
        global base_units
        unknown_units = setdiff(keys(unit_specs),
                                keys(base_units))
        length(unknown_units) != 0 && error("Unknown base unit, $(join(unknown_units, ", "))")

        for (k,v) in unit_specs
            base_units[k] = v
        end

        nothing
    end

    macro set_base_units(spec)
        spec.head == :-> ||
            error("Expected a block with parameters for definition of the field")
        block = spec.args[2]
        block.head == :block ||
            error("Expected a block with parameters for definition of the field")

        set_base_units(parse_block(block, Any))
    end

    export @set_base_units

    usplit(u) = ustrip(u),unit(u)
  #+END_SRC

  #+RESULTS:
  : usplit (generic function with 1 method)

* DSLs
** Parse assignment DSL blocks
   #+BEGIN_SRC julia
     function parse_block(block, T)
         line_no = 0
         filename = ""
         error_message = v -> error("$(filename):$(line_no)\n>   $(v)")

         field_params = Dict{Symbol,T}()
         param_line_nos = Dict()

         for line in block.args
             typeof(line) == Expr || error_message("Expected expression, got $(line)")
             if line.head == :line
                 line_no,filename = line.args
                 continue
             end
             line.head == Symbol("=") ||
                 error_message("Expected “parameter = value expression”, got $(line)")
             k = line.args[1]
             k in keys(field_params) &&
                 error_message("Field parameter $(k) already specified at $(filename):$(param_line_nos[k])")
             v = line.args[2]
             field_params[k] = eval(v)
             param_line_nos[k] = line_no
         end

         field_params
     end
   #+END_SRC

   #+RESULTS:
   : parse_block (generic function with 1 method)

** DSL for calculation of quantities
   The somewhat complicated setup with walking the expression tree in
   =make_field= (twice implemented :) allows for very clean expression
   of the formulaic dependencies between different quantities, almost
   as if it were pure math. All ingoing quantities are either unitful,
   or made unitful using the set base units. Furthermore, outgoing
   quantities are transformed to the base units, even though the
   expression may result in a different (but equivalent) unit
   expression. This way, even if a period time is provided in
   femtoseconds, the wavenumber will always be returned in Kaysers, for
   instance.

*** Testing presence of quantity in the namespace
    These methods are used for the =if x= constructs in the quantity
    conversion DSL. We return =true= if the symbol =x= is present in the
    =params= dict. Since we implement it as an expression walking
    algorithm, we can have constructs as =if x || y=, which will expand
    to =if :x in keys(params) || :y in keys(params)=.
    #+BEGIN_SRC julia
      test_symbol_walk(node, params) = node
      test_symbol_walk(node::Symbol, params) = (isdefined(node) ?
                                                node :
                                                Expr(:call, :in, Expr(:quote, node),
                                                     Expr(:call, :keys, params)))
      test_symbol_walk(node::Expr, params) =
          Expr(node.head, test_symbol_walk.(node.args, params)...)
    #+END_SRC

    #+RESULTS:
    : test_symbol_walk (generic function with 3 methods)

*** Expression walker
    This walks the quantity conversions block, replacing symbols with
    references to dictionary items and converting quantities to
    applicable base units, before assignment.
    #+BEGIN_SRC julia
      walk(node, params) = node
      walk(node::Symbol, params) = node

      get_reference(r::Symbol,params) = Expr(:ref, params, Expr(:quote, r))
      get_reference(r,params) = r

      get_symbol(s::Symbol, params) = isdefined(s) ? s : get_reference(s, params)
      get_symbol(s, params) = s

      function walk(node::Expr, params)
          if node.head ∈ [:line, :quote]
              node
          elseif node.head == :if
              # Dispatch "if x" to test_symbol_walk, which checks if :x is
              # present as key in params.
              args = [test_symbol_walk(node.args[1], params)]
              append!(args, [walk(a, params) for a in node.args[2:end]])
              Expr(node.head, args...)
          else
              args = [walk(a, params) for a in node.args]
              if node.head == :(=)
                  r = get_reference(args[1], params)
                  if typeof(args[1]) == Symbol && args[1] ∈ keys(base_units)
                      # Generate expression that converts to the correct
                      # base unit.
                      conv = Expr(:call, :|>, args[2],
                                  Expr(:ref, base_units,
                                       Expr(:quote, args[1])))
                      Expr(node.head, r, conv)
                  else
                      Expr(node.head, r, get_symbol(args[2], params))
                  end
              else
                  args = get_symbol.(args, params)
                  Expr(node.head, args...)
              end
          end
      end
    #+END_SRC

    #+RESULTS:
    : walk (generic function with 3 methods)

*** Namespace macro
    This macro uses the dictionary =params= as a "namespace", i.e. all
    symbols are assumed to be keys in this dictionary.
    #+BEGIN_SRC julia
      macro namespace!(exprs, params)
          local tree = walk(exprs, esc(params))
          quote
              $tree()
          end
      end
    #+END_SRC

    #+RESULTS:
    : @namespace! (macro with 1 method)

*** Test of "competing quantities"
    This function ensures that one and only one of "competing"
    quantities is specified.
    #+BEGIN_SRC julia
      function test_field_parameters(field_params, set)
          info = set ∩ keys(field_params)
          set_string = join(set, ", ", " and ")

          length(info) == 0 &&
              (length(set) > 1 && error("Need to provide one of $(set_string)") ||
               error("Required parameter $(set_string) missing"))
          length(info) > 1 &&
              error("Can only specify one of $(set_string)")

          info
      end
    #+END_SRC

    #+RESULTS:
    : test_field_parameters (generic function with 1 method)

* Field types
  #+BEGIN_SRC julia
    abstract type AbstractField end
    abstract type AbstractCarrier end
    abstract type AbstractEnvelope end

    # # Not possible in current version of Julia
    # # https://github.com/JuliaLang/julia/issues/14919
    # (f::AbstractField)(t::Number) = envelope(f)(t)*carrier(f)(t)

    wavelength(f::AbstractField) = wavelength(carrier(f))
    period(f::AbstractField) = period(carrier(f))

    frequency(f::AbstractField) = frequency(carrier(f)) |> base_units[:f]
    max_frequency(f::AbstractField) = max_frequency(carrier(f)) |> base_units[:f]
    wavenumber(f::AbstractField) = wavenumber(carrier(f))
    fundamental(f::AbstractField) = fundamental(carrier(f))
    energy(f::AbstractField) = energy(carrier(f))


    intensity(f::AbstractField) = intensity(envelope(f))
    amplitude(f::AbstractField) = amplitude(envelope(f))
    duration(f::AbstractField) = duration(envelope(f))
    continuity(f::AbstractField) = continuity(envelope(f))
  #+END_SRC

  #+RESULTS:
  : nothing
** Linear field
   #+BEGIN_SRC julia
     struct LinearField <: AbstractField
         carrier::AbstractCarrier
         env::AbstractEnvelope # Amplitude envelope
         params::Dict{Symbol, Any}
     end

     (f::LinearField)(t::Number) = f.carrier(t)*f.env(t)

     function show(io::IO, f::LinearField)
         write(io, "Linearly polarized field with a\n  ")
         show(io, f.carrier)
         write(io, " and a\n  ")
         show(io, f.env)
     end

     carrier(f::LinearField) = f.carrier
     envelope(f::LinearField) = f.env
     params(f::LinearField) = f.params
   #+END_SRC

   #+RESULTS:
   : params (generic function with 1 method)

** Transverse field
   #+BEGIN_SRC julia
     struct TransverseField <: AbstractField
         z::LinearField
         x::LinearField
     end

     duration(f::TransverseField) = max(duration.((f.z,f.x))...)
   #+END_SRC

   #+RESULTS:
   : duration (generic function with 2 methods)

** Keldysh parameter
   The [[https://en.wikipedia.org/wiki/Tunnel_ionization][Keldysh parameter]] relates the strength of a dynamic electric
   field to that of the binding potential of an atom. It is given by

   \[\gamma = \sqrt{\frac{I_p}{2U_p}},\]

   where \(I_p\) is the ionization potential of the atom and \(U_p\)
   is the ponderomotive potential of the dynamic field.
   #+BEGIN_SRC julia
     # TODO: Should require Iₚ to be of unit energy
     keldysh(f::AbstractField, Iₚ::Number) = NoUnits(√(Iₚ/2params(f)[:Uₚ]))
   #+END_SRC

   #+RESULTS:
   : keldysh (generic function with 1 method)

** Exports
   #+BEGIN_SRC julia
     export carrier,
         wavelength, period,
         frequency, max_frequency, wavenumber, fundamental, energy,
         envelope,
         intensity, amplitude,
         duration,
         params,
         keldysh
   #+END_SRC

   #+RESULTS:
   : nothing

* Time axis
  We construct the time axis such that the highest frequency component
  of the field is resolved. By the Nyquist sampling theorem, we need
  minimum \(f_s>2f_{\textrm{max}}\), but to be on the safe side, we
  use, as default, \(f_s=100f_{\textrm{max}}\). This also makes plots
  nicer.
  #+BEGIN_SRC julia
    span(f::AbstractField) = span(envelope(f))

    const DEFAULT_SAMPLING_FACTOR = 100
    default_sampling_frequency(f::AbstractField) = DEFAULT_SAMPLING_FACTOR*max_frequency(f)

    steps(f::AbstractField, fs::Unitful.Frequency=default_sampling_frequency(f)) =
        ceil(Int, fs*abs(-(span(f)...)))
    steps(f::AbstractField, ndt::Integer) = steps(f, ndt/period(f))

    timeaxis(f::AbstractField, fs::Unitful.Frequency=default_sampling_frequency(f)) =
        linspace(span(f)..., steps(f, fs))
    timeaxis(f::AbstractField, ndt::Integer) = linspace(span(f)..., steps(f, ndt))

    export span, steps, timeaxis
  #+END_SRC

* Carriers
  #+BEGIN_SRC julia :results value verbatim
    carrier_types = Dict{Symbol,Any}()

    max_frequency(carrier::AbstractCarrier) = frequency(carrier)
  #+END_SRC

  #+RESULTS:
  : max_frequency (generic function with 3 methods)

** Fixed carrier
   The carrier is fixed in the sense that the instantaneous frequency
   is constant throughout the pulse.
   #+BEGIN_SRC julia
     struct FixedCarrier <: AbstractCarrier
         λ::Number
         T::Number
         ω::Number
         ϕ::Number # Carrier–envelope phase, in radians
     end

     (carrier::FixedCarrier)(t::Number) = sin(carrier.ω*t + carrier.ϕ)

     carrier_types[:fixed] = FixedCarrier

     wavelength(carrier::FixedCarrier) = carrier.λ
     period(carrier::FixedCarrier) = carrier.T

     frequency(carrier::FixedCarrier) = 1/carrier.T
     wavenumber(carrier::FixedCarrier) = 1/carrier.λ
     fundamental(carrier::FixedCarrier) = carrier.ω
     energy(carrier::FixedCarrier) = carrier.ω * u"hbar"

     function FixedCarrier(field_params::Dict{Symbol,Any})
         @unpack λ, T, ω = field_params
         ϕ = get(field_params, :ϕ, 0)
         FixedCarrier(λ, T, ω, ϕ)
     end

     function show(io::IO, carrier::FixedCarrier)
         write(io, @sprintf("Fixed carrier @ λ = %0.2f %s (T = %0.2f %s)",
                            usplit(carrier.λ)..., usplit(carrier.T)...))
         if carrier.ϕ != 0
             write(io, @sprintf("; CEP = %0.2fπ", carrier.ϕ/π))
         end
     end
   #+END_SRC

   #+RESULTS:
   : show (generic function with 259 methods)

** Dispersed carriers [0/2]
*** TODO Chirped carrier
*** TODO Sellmeier equations
* Envelopes [2/3]
  The envelopes implemented below are all /amplitude/ envelopes,
  since that is what is being used in calculations. However, they may
  be specified using intensity-related quantities, e.g. Gaussian
  pulses are most often specified using the FWHM duration of their
  /intensity/ envelopes.

  #+BEGIN_SRC julia :results value verbatim
    envelope_types = Dict{Symbol,Any}()
  #+END_SRC

  #+RESULTS:
  : Dict{Symbol,Any} with 0 entries

** DONE Gaussian
   A Gaussian pulse is given by

   \[I_0\exp\left(-\frac{t^2}{2\sigma^2}\right),\]

   where the standard deviation σ is related to the FWHM duration τ
   of the intensity envelope as

   \[\sigma = \frac{\tau}{2\sqrt{2\ln 2}}.\]

   Furthermore, the /amplitude/ standard deviation σ′ is proportional
   to the intensity ditto: \(\sigma' = \sqrt{2}\sigma\). Therefore,
   the amplitude envelope is given by

   \[E_0\exp\left(-\frac{t^2}{2{\sigma'}^2}\right)
   =E_0\exp\left(-\frac{t^2}{4\sigma^2}\right)
   =E_0\exp\left(-\frac{2\ln2t^2}{\tau^2}\right).\]

   Since a Gaussian never ends, we specify how many σ we
   require; the resulting time window will be rounded up to an
   integer amount of cycles of the fundamental.

   #+BEGIN_SRC julia
     struct GaussianEnvelope <: AbstractEnvelope
         τ::Number # Intensity FWHM
         σ::Number # Intensity std.dev.
         σ′::Number # Envelope std.dev.
         σmax::Number
         σ′max::Number
         tmax::Number # Maximum time. Time window: [-tmax,tmax]
         Tmax::Integer # Maximum time, in cycles of the fundamental.
         I₀::Number
         E₀::Number
     end
     envelope_types[:gauss] = GaussianEnvelope

     (env::GaussianEnvelope)(t::Number) = env.E₀*exp(-t^2/(2*env.σ′^2))

     show(io::IO, env::GaussianEnvelope) =
         write(io, @sprintf("I₀ = %0.2g %s Gaussian envelope of duration %0.2g %s (intensity FWHM; ±%0.2fσ) ",
                            usplit(env.I₀)..., usplit(env.τ)..., env.σmax))

     function GaussianEnvelope(field_params::Dict{Symbol,Any})
         test_field_parameters(field_params, [:T]) # Period time required to round time window up
         test_field_parameters(field_params, [:τ, :σ, :σ′])
         test_field_parameters(field_params, [:σmax, :σ′max, :tmax, :Tmax])

         @namespace!(field_params) do
             if τ
                 σ = τ/(2*√(2log(2)))
             else
                 if σ′
                     σ = σ′/√2
                 end
                 τ = 2*√(2log(2))*σ
             end
             if !σ′
                 σ′ = √2*σ
             end

             if σmax || σ′max
                 if σmax
                     Tmax = ceil(Int, σmax*σ/T)
                 elseif σ′max
                     Tmax = ceil(Int, σ′max*σ′/T)
                 end
                 tmax = Tmax*T
             else
                 if tmax
                     Tmax = ceil(Int, tmax/T)
                 elseif Tmax
                     tmax = Tmax*T
                 end
             end
             σmax = tmax/σ
             σ′max = tmax/σ′
         end

         @unpack τ, σ, σ′, σmax, σ′max, tmax, Tmax, I₀, E₀ = field_params
         GaussianEnvelope(τ, σ, σ′, σmax, σ′max, tmax, Tmax, I₀, E₀)
     end

     continuity(::GaussianEnvelope) = Inf
     span(env::GaussianEnvelope) = (-env.tmax, env.tmax)
   #+END_SRC

   #+RESULTS:
   : span (generic function with 2 methods)

** DONE Trapezoidal
   #+BEGIN_SRC julia
     struct TrapezoidalEnvelope <: AbstractEnvelope
         ramp_up::Number
         flat::Number
         ramp_down::Number
         I₀::Number
         E₀::Number
         T::Number
     end
     envelope_types[:trapezoidal] = TrapezoidalEnvelope
     # Common alias
     envelope_types[:tophat] = TrapezoidalEnvelope

     function (env::TrapezoidalEnvelope)(t::Number)
         t /= env.T
         f = if t < 0
             0
         elseif t < env.ramp_up
             t/env.ramp_up
         elseif t < env.ramp_up + env.flat
             1
         elseif t < env.ramp_up + env.flat + env.ramp_down
             1 - (t-env.ramp_up-env.flat)/env.ramp_down
         else
             0
         end
         f*env.E₀
     end

     show(io::IO, env::TrapezoidalEnvelope) =
         write(io, @sprintf("I₀ = %0.2g %s /%s‾%s‾%s\\ cycles trapezoidal envelope",
                            usplit(env.I₀)...,
                            env.ramp_up, env.flat, env.ramp_down))

     function TrapezoidalEnvelope(field_params::Dict{Symbol,Any})
         test_field_parameters(field_params, [:T]) # Period time required to relate ramps/flat to cycles
         test_field_parameters(field_params, [:ramp, :ramp_up])
         test_field_parameters(field_params, [:ramp, :ramp_down])
         test_field_parameters(field_params, [:flat])

         @namespace!(field_params) do
             if ramp
                 ramp_up = ramp
                 ramp_down = ramp
             end
         end

         @unpack ramp_up, flat, ramp_down, I₀, E₀, T = field_params

         ramp_up >= 0 || error("Negative up-ramp not supported")
         flat >= 0 || error("Negative flat region not supported")
         ramp_down >= 0 || error("Negative down-ramp not supported")
         ramp_up + flat + ramp_down > 0 || error("Pulse length must be non-zero")

         TrapezoidalEnvelope(ramp_up, flat, ramp_down, I₀, E₀, T)
     end

     continuity(::TrapezoidalEnvelope) = 0
     span(env::TrapezoidalEnvelope) = (0u"fs", (env.ramp_up + env.flat + env.ramp_down)*env.T)
   #+END_SRC

   #+RESULTS:
   : span (generic function with 3 methods)

** TODO Sin2

** Exports
   #+BEGIN_SRC julia
     export continuity
   #+END_SRC

   #+RESULTS:
   : nothing

* TODO Field arithmetic [0/1]
  For calculations, a time-base is necessary ("normalized time"), with
  respect to which all harmonic motions &c are analyzed.  When
  combining fields of commensurate frequencies, it is easy to
  establish a common time-base, most likely the fundamental wavelength
  will be the obvious choice -- such as when adding an IR field and its
  harmonic components as generated through e.g. HHG:

  \[E(t) = \sum_q E_{2q + 1}(t)\sin[(2q+1)\omega t].\]

  However, when adding incommensurate frequencies, there is no obvious
  choice, so the user has to specify the time-base explicitly -- maybe
  by the order in which the fields are added?

  There should also be some helper routines that, when discretizing
  the time axis, estimate whether all harmonic components of interest
  are satisfactorily resolved.

  #+BEGIN_SRC julia
    import Base: +, -

    type SumField <: AbstractField
        a::AbstractField
        b::AbstractField
    end

    +(a::AbstractField,
      b::AbstractField) = SumField(a, b)

    function span(f::SumField)
        sa = span(a)
        sb = span(b)
        (min(sa[1], sb[1]), max(sa[2],sb[2]))
    end


    type NegatedField <: AbstractField
        a::AbstractField
    end

    -(a::AbstractField,
      b::AbstractField) = SumField(a, NegatedField(b))


    type DelayedField <: AbstractField
        a::AbstractField
        t₀::Number
    end

    span(f::DelayedField) = span(f.a) .+ f.t₀
  #+END_SRC

  #+RESULTS:
  : span (generic function with 5 methods)

** TODO Delay operators
   Convention for delayed fields: a field delayed by a /positive/
   time, comes /later/, i.e. we write \(f(t-\delta t)\).
   #+BEGIN_SRC julia
     delay(a::AbstractField, t₀::Number) = DelayedField(a, t₀)
     delay(a::DelayedField) = a.t₀
     delay(a::AbstractField) = 0

     # Dispatch evaluation on units: time shift, radians, cycles
   #+END_SRC

   #+RESULTS:
   : nothing
* Field creation
** Parameter calculation
   This function performs the calculation of different quantities from
   the information provided.

   The [[https://en.wikipedia.org/wiki/Ponderomotive_energy][ponderomotive potential]] U_p is the cycle-average quiver energy
   of a free electron in an electromagnetic field. It is given by

   \[U_p =
   \frac{e^2E_0^2}{4m\omega^2}=\frac{2e^2}{c\varepsilon_0m}\times\frac{I}{4\omega^2},
   \]

   or, in atomic units,

   \[U_p = \frac{I}{4\omega^2}.\]

   #+BEGIN_SRC julia
     function calc_params!(field_params::Dict{Symbol,Any})
         test_field_parameters(field_params, [:λ, :T, :f, :ν, :ω])
         test_field_parameters(field_params, [:I₀, :E₀, :Uₚ])

         for k in keys(field_params)
             field_params[k] = get_unitful_quantity(field_params, k)
         end

         @namespace!(field_params) do
             if λ || T
                 if λ
                     T = λ/u"c"
                 elseif T
                     λ = T*u"c"
                 end
                 ν = 1/λ
                 f = 1/T
                 ω = 2π*u"rad"*f
             else # ∝ Frequency specified
                 if f || ν
                     if f
                         ν = f/u"c"
                     elseif ν
                         f = ν*u"c"
                     end
                     ω = 2π*u"rad"*f
                 else ω
                     f = ω/(2π*u"rad")
                     ν = f/u"c"
                 end
                 T = 1/f
                 λ = 1/ν
             end

             if I₀ || Uₚ
                 if Uₚ
                     I₀ = Uₚ / (2*u"q"^2/(u"c"*u"ε0"*u"me")) * 4ω^2
                 end
                 E₀ = √(2I₀/(u"ε0"*u"c"))
             elseif E₀
                 I₀ = u"ε0"*u"c"/2*E₀^2
             end
             if !Uₚ
                 Uₚ = 2*u"q"^2/(u"c"*u"ε0"*u"me") * I₀/4ω^2
             end
         end

         field_params
     end
   #+END_SRC

   #+RESULTS:
   : calc_params! (generic function with 1 method)

** Frontend macro
   #+BEGIN_SRC julia
     function make_field(field_params::Dict{Symbol,Any})
         calc_params!(field_params)

         # Maybe these two blocks can be implicitly deduced from the passed
         # parameters? E.g. if a chirp parameter is given, the carrier type
         # should autmatically be resolved as ChirpedCarrier. Similarly, if
         # ramp and flat are given, a trapezoidal pulse is requested.

         carrier_sym = get(field_params, :carrier, :fixed)
         carrier_sym ∉ keys(carrier_types) &&
             error("Unknown carrier type $(carrier_sym), valid choices are $(keys(carrier_types))")
         carrier = carrier_types[carrier_sym](field_params)

         env_sym = get(field_params, :env, :gauss)
         env_sym ∉ keys(envelope_types) &&
             error("Unknown envelope type $(env_sym), valid choices are $(keys(envelope_types))")
         env = envelope_types[env_sym](field_params)

         :ξ in keys(field_params) &&
             error("Elliptical (transverse) fields not yet supported!")

         LinearField(carrier, env, field_params)
     end

     macro field(spec, var)
         spec.head == :-> ||
             error("Expected a block with parameters for definition of the field")
         block = spec.args[2]
         block.head == :block ||
             error("Expected a block with parameters for definition of the field")

         field_params = parse_block(block, Any)
         quote
             $(esc(var)) = make_field($field_params)
         end
     end

     export @field
   #+END_SRC

   #+RESULTS:
   : nothing

* EXAMPLE Usage
**** Specifying wavelength
     A [[https://en.wikipedia.org/wiki/Gaussian_function][Gaussian envelope]] is the default and can be omitted; τ refers
     the [[https://en.wikipedia.org/wiki/Full_width_at_half_maximum][FWHM]] duration of the intensity envelope.
     #+BEGIN_SRC julia :exports both :results value verbatim
       @field(IR) do
           λ  = 800.0
           I₀ = 1e14
           τ  = 6.2
           Tmax = 10
           env = :gauss
       end
     #+END_SRC

     #+RESULTS:
     : Linearly polarized field with a
     :   Fixed carrier @ λ = 800.00 nm (T = 2.67 fs) and a
     :   I₀ = 1e+14 cm^-2 W Gaussian envelope of duration 6.2 fs (intensity FWHM; ±10.14σ)

**** Trapezoidal envelope
     A trapezoidal envelope (also known as a tophat pulse) has a
     ramp-up, a flat region, and a ramp-down.
     #+BEGIN_SRC julia :exports both :results value verbatim
       @field(XUV) do
           λ    = 800.0u"nm"
           I₀   = 1e10u"W/cm^2"
           q    = 3:2:17 # Harmonic orders of 800 nm
           env  = :trapezoidal
           ramp = 5
           flat = 10
       end
     #+END_SRC

     #+RESULTS:
     : Linearly polarized field with a
     :   Fixed carrier @ λ = 800.00 nm (T = 2.67 fs) and a
     :   I₀ = 1e+10 cm^-2 W /5‾10‾5\ cycles trapezoidal envelope

**** Specifying period time, other base units
     #+BEGIN_SRC julia :exports both :results value verbatim
       @set_base_units() do
           λ  = u"km"
       end

       @field(radio) do
           T     = 3.0u"ms"
           E₀    = 5u"V/m"
           τ     = 10u"s"
           σ′max = 5
       end
     #+END_SRC

     #+RESULTS:
     : Linearly polarized field with a
     :   Fixed carrier @ λ = 899.38 km (T = 3.00 ms) and a
     :   I₀ = 3.3e-06 cm^-2 W Gaussian envelope of duration 10 s (intensity FWHM; ±7.07σ)
