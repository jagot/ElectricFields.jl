#+TITLE: ElectricFields.jl
#+AUTHOR: Stefanos Carlström
#+EMAIL: stefanos.carlstrom@gmail.com

#+PROPERTY: header-args:julia :session *julia-ElectricFields*

The idea of this package is to provide an interface between the
reality and calculations. In the calculations, it is useful to
represent fields in terms of cycles of a /fundamental/ frequency,
which yields a timebase. E.g. one might use laser pulses of 800 nm, in
an experiment, which has a period time of about 2.66 fs. It is,
however, easier to calculate in normalized time, and relate all other
quantities of interest (such as ionization potential, &c) to this time
scale.

The package provides a simple DSL that requires just a handful of
parameters, that can be given in /any/ unit system (thanks to
[[https://github.com/ajkeller34/Unitful.jl][Unitful.jl]]). Different fields can be combined in any way that is
physically reasonable, to recreate complicated experimental
situations. Everything can then be converted to normalized time, for
use in calculations.

* Field types
  #+BEGIN_SRC julia
    using Unitful

    abstract type AbstractField end

    struct LinearField <: AbstractField
        λ::Number
        T::Number
        ω::Number
        τ::Number
    end

    wavelength(f::LinearField) = f.λ
    period(f::LinearField) = f.T

    frequency(f::LinearField) = 1/f.T
    wavenumber(f::LinearField) = 1/f.λ
    fundamental(f::LinearField) = f.ω
    energy(f::LinearField) = f.ω * u"hbar"

    duration(f::LinearField) = f.τ

    intensity(f::LinearField) = 0
    amplitude(f::LinearField) = 0

    struct TransverseField <: AbstractField
        z::LinearField
        x::LinearField
    end

    duration(f::TransverseField) = max(duration.((f.z,f.x))...)
  #+END_SRC

  #+RESULTS:

** Field arithmetic
   #+BEGIN_SRC julia
     type SumField <: AbstractField
         a::AbstractField
         b::AbstractField
     end

     +(a::AbstractField,
       b::AbstractField) = SumField(a, b)


     type NegatedField <: AbstractField
         a::AbstractField
     end

     -(a::AbstractField,
       b::AbstractField) = SumField(a, NegatedField(b))


     type DelayedField <: AbstractField
         a::AbstractField
         t₀::Number
     end
   #+END_SRC

   #+RESULTS:
   : nothing

   Convention for delayed fields: a field delayed by a /positive/
   time, comes /later/, i.e. we write \(f(t-\delta t)\).
   #+BEGIN_SRC julia
     delay(a::AbstractField, t₀::Number) = DelayedField(a, t₀)
     delay(a::DelayedField) = a.t₀
     delay(a::AbstractField) = 0

     # Dispatch evaluation on units: time shift, radians, cycles
   #+END_SRC

   #+RESULTS:
   : nothing

* Parse DSL blocks
  #+BEGIN_SRC julia
    function parse_block(block, T)
        line_no = 0
        filename = ""
        error_message = v -> error("$(filename):$(line_no)\n>   $(v)")

        field_params = Dict{Symbol,T}()
        param_line_nos = Dict()

        for line in block.args
            typeof(line) == Expr || error_message("Expected expression, got $(line)")
            if line.head == :line
                line_no,filename = line.args
                continue
            end
            line.head == Symbol(":") ||
                error_message("Expected “parameter : value expression”, got $(line)")
            k = line.args[1]
            k in keys(field_params) &&
                error_message("Field parameter $(k) already specified at $(filename):$(param_line_nos[k])")
            v = line.args[2]
            field_params[k] = eval(v)
            param_line_nos[k] = line_no
        end

        field_params
    end
  #+END_SRC

  #+RESULTS:
  : parse_block

* Units
  #+BEGIN_SRC julia
    base_units = Dict(:λ => u"nm",
                      :I₀ => u"W/cm^2",
                      :E₀ => u"V/m",
                      :τ => u"fs",
                      :T => u"s",
                      :f => u"Hz",
                      :ν => u"cm^-1",
                      :ω => u"rad/s")

    function get_unitful_quantity(field_params::Dict{Symbol,Union{Number,Quantity}}, sym::Symbol)
        v = field_params[sym]
        typeof(v) <: Quantity ? v : v*base_units[sym]
    end

    function set_base_units(unit_specs::Dict{Symbol, Any})
        global base_units
        unknown_units = setdiff(keys(unit_specs),
                                keys(base_units))
        length(unknown_units) != 0 && error("Unknown base unit, $(join(unknown_units, ", "))")

        for (k,v) in unit_specs
            base_units[k] = v
        end

        nothing
    end

    macro set_base_units(spec)
        spec.head == :-> ||
            error("Expected a block with parameters for definition of the field")
        block = spec.args[2]
        block.head == :block ||
            error("Expected a block with parameters for definition of the field")

        set_base_units(parse_block(block, Any))
    end

    export @set_base_units
  #+END_SRC

  #+RESULTS:
  : nothing

* Field creation
** DSL for calculation of quantities
   The somewhat complicated setup with walking the expression tree in
   =make_field= (twice implemented :) allows for very clean expression
   of the formulaic dependencies between different quantities, almost
   as if it were pure math. All ingoing quantities are either unitful,
   or made unitful using the set base units. Furthermore, outgoing
   quantities are transformed to the base units, even though the
   expression may result in a different (but equivalent) unit
   expression. This way, even if a period time is provided in
   femtoseconds, the wavenumber will always be returned in Kaysers, for
   instance.

   These methods are used for the =if x= constructs in the quantity
   conversion DSL. We return =true= if the symbol =x= is present in the
   =params= dict. Since we implement it as an expression walking
   algorithm, we can have constructs as =if x || y=, which will expand
   to =if :x in keys(params) || :y in keys(params)=.
   #+BEGIN_SRC julia
     test_symbol_walk(node, params) = node
     test_symbol_walk(node::Symbol, params) = (isdefined(node) ?
                                               node :
                                               Expr(:call, :in, Expr(:quote, node),
                                                    Expr(:call, :keys, params)))
     test_symbol_walk(node::Expr, params) =
         Expr(node.head, test_symbol_walk.(node.args, params)...)
   #+END_SRC

   #+RESULTS:
   : test_symbol_walk

   This walks the quantity conversions block, replacing symbols with
   references to dictionary items and converting quantities to
   applicable base units, before assignment.
   #+BEGIN_SRC julia
     walk(node, params) = node
     walk(node::Symbol, params) = node

     get_reference(r::Symbol,params) = Expr(:ref, params, Expr(:quote, r))
     get_reference(r,params) = r

     get_symbol(s::Symbol, params) = isdefined(s) ? s : get_reference(s, params)
     get_symbol(s, params) = s

     function walk(node::Expr, params)
         if node.head ∈ [:line, :quote]
             node
         elseif node.head == :if
             # Dispatch "if x" to test_symbol_walk, which checks if :x is
             # present as key in params.
             args = [test_symbol_walk(node.args[1], params)]
             append!(args, [walk(a, params) for a in node.args[2:end]])
             Expr(node.head, args...)
         else
             args = [walk(a, params) for a in node.args]
             if node.head == :(=)
                 r = get_reference(args[1], params)
                 if typeof(args[1]) == Symbol
                     # Generate expression that converts to the correct
                     # base unit.
                     conv = Expr(:call, :|>, args[2],
                                 Expr(:ref, base_units,
                                      Expr(:quote, args[1])))
                     Expr(node.head, r, conv)
                 else
                     Expr(node.head, args...)
                 end
             else
                 args = get_symbol.(args, params)
                 Expr(node.head, args...)
             end
         end
     end
   #+END_SRC

   #+RESULTS:
   : walk

   This macros uses the dictionary =params= as a "namespace", i.e. all
   symbols are assumed to be keys in this dictionary.
   #+BEGIN_SRC julia
     macro namespace!(exprs, params)
         local tree = walk(exprs, esc(params))
         quote
             $tree()
         end
     end
   #+END_SRC

   #+RESULTS:
   : @namespace!

   This function ensures that one and only one of "competing"
   quantities is specified.
   #+BEGIN_SRC julia
     function test_field_parameters(field_params, set)
         info = set ∩ keys(field_params)
         set_string = join(set, ", ", " and ")

         length(info) == 0 &&
             error("Need to provide one of $(set_string)")
         length(info) > 1 &&
             error("Can only specify one of $(set_string)")

         info
     end
   #+END_SRC

   #+RESULTS:
   : test_field_parameters

** Parameter calculation
   This function performs the calculation of different quantities from
   the information provided.

   #+BEGIN_SRC julia
     function make_field(field_params::Dict{Symbol,Union{Number,Quantity}})
         carrier_info = test_field_parameters(field_params, [:λ, :T, :f, :ν, :ω])
         amplitude_info = test_field_parameters(field_params, [:I₀, :E₀])

         for k in keys(field_params)
             field_params[k] = get_unitful_quantity(field_params, k)
         end

         @namespace!(field_params) do
             if λ || T
                 if λ
                     T = λ/u"c"
                 elseif T
                     λ = T*u"c"
                 end
                 ν = 1/λ
                 f = 1/T
                 ω = 2π*u"rad"*f
             else # ∝ Frequency specified
                 if f || ν
                     if f
                         ν = f/u"c"
                     elseif ν
                         f = ν*u"c"
                     end
                     ω = 2π*u"rad"*f
                 else ω
                     f = ω/(2π*u"rad")
                     ν = f/u"c"
                 end
                 T = 1/f
                 λ = 1/ν
             end

             if I₀
                 E₀ = √(2I₀/u"ε0*c")
             elseif E₀
                 I₀ = u"ε0*c"/2*E₀^2
             end
         end

         field_params
     end
   #+END_SRC

   #+RESULTS:
   : make_field

** Frontend macro
   #+BEGIN_SRC julia
     macro field(spec, var)
         spec.head == :-> ||
             error("Expected a block with parameters for definition of the field")
         block = spec.args[2]
         block.head == :block ||
             error("Expected a block with parameters for definition of the field")

         field_params = parse_block(block, Number)
         quote
             $(esc(var)) = make_field($field_params)
         end
     end

     export @field
   #+END_SRC

   #+RESULTS:
   : nothing

*** COMMENT Example usage
**** Specifying wavelength
     #+BEGIN_SRC julia :exports both :results value code
       @field(IR) do
           λ  : 800.0
           I₀ : 1e14
           τ  : 6.2
       end
     #+END_SRC

     #+RESULTS:
     #+begin_src julia
     Dict{Symbol,Number}(Pair{Symbol,Number}(:T, 2.66851e-15 s),Pair{Symbol,Number}(:ν, 12500.0 cm^-1),Pair{Symbol,Number}(:f, 3.74741e14 Hz),Pair{Symbol,Number}(:E₀, 2.74492e10 m^-1 V),Pair{Symbol,Number}(:λ, 800.0 nm),Pair{Symbol,Number}(:I₀, 1.0e14 cm^-2 W),Pair{Symbol,Number}(:τ, 6.2 fs),Pair{Symbol,Number}(:ω, 2.35456e15 rad s^-1))
     #+end_src

**** Specifying period time
     #+BEGIN_SRC julia :exports both :results value code
       @set_base_units() do
           λ  : u"km"
       end

       @field(radio) do
           T  : 3.0u"ms"
           E₀ : 5u"V/m"
           τ  : 10u"s"
       end
     #+END_SRC

     #+RESULTS:
     #+begin_src julia
     Dict{Symbol,Number}(Pair{Symbol,Number}(:T, 3.0 ms),Pair{Symbol,Number}(:ν, 1.11188e-8 cm^-1),Pair{Symbol,Number}(:f, 333.333 Hz),Pair{Symbol,Number}(:E₀, 5 m^-1 V),Pair{Symbol,Number}(:λ, 899.377 km),Pair{Symbol,Number}(:τ, 10 s),Pair{Symbol,Number}(:ω, 2094.4 rad s^-1),Pair{Symbol,Number}(:I₀, 3.31802e-6 cm^-2 W))
     #+end_src
