#+TITLE: ElectricFields.jl
#+AUTHOR: Stefanos Carlstr√∂m
#+EMAIL: stefanos.carlstrom@gmail.com

#+PROPERTY: header-args:julia :session *julia-ElectricFields*

The idea of this package is to provide an interface between the
reality and calculations. In the calculations, it is useful to
represent fields in terms of cycles of a /fundamental/ frequency,
which yields a timebase. E.g. one might use laser pulses of 800¬†nm, in
an experiment, which has a period time of about 2.66¬†fs. It is,
however, easier to calculate in normalized time, and relate all other
quantities of interest (such as ionization potential, &c) to this time
scale.

The package provides a simple DSL that requires just a handful of
parameters, that can be given in /any/ unit system (thanks to
[[https://github.com/ajkeller34/Unitful.jl][Unitful.jl]]). Different fields can be combined in any way that is
physically reasonable, to recreate complicated experimental
situations. Everything can then be converted to normalized time, for
use in calculations.

* Setup
  #+BEGIN_SRC julia
    using Unitful
    using FFTW
    using Parameters
    import Base: show
    using Printf
  #+END_SRC

  #+RESULTS:
  : nothing

* Todo
  - [-] Automatic time/frequency axes
    - [X] Calculation of time span from envelope
    - [ ] Calculation of maximal frequency of all fields
  - [ ] Delayed fields
  - [ ] Field arithmetic
  - [ ] Simple evaluation of field spectrum
    - [ ] Default implementation uses FFT
    - [ ] Concrete types may provide analytic implementations
  - [ ] Common time-base
  - [ ] Temporal discretization
  - [ ] Conversion to atomic units
  - [ ] Arbitrary fields
  - [ ] Tests

* Dimensions
  #+BEGIN_SRC julia
    @derived_dimension ElectricField Unitful.ùêà^-1*Unitful.ùêã*Unitful.ùêå*Unitful.ùêì^-3
    @derived_dimension Intensity Unitful.ùêå*Unitful.ùêì^-3
  #+END_SRC

  #+RESULTS:
  : nothing

* Misc
** TEST
   #+BEGIN_SRC julia
     using Test
     using Unitful
   #+END_SRC

   #+RESULTS:
   : nothing

** EXAMPLE
   #+BEGIN_SRC julia
     using PyPlot

     mkpath("../images")

     function savefig_f(filename)
         filename = "../images/$(filename).svg"
         savefig(filename, transparent=true)
         filename
     end

     import PyPlot: plot
     # Convenience overloads for plotting unitful vectors
     plot(t::AbstractVector{<:Unitful.Time}, y, args...; kwargs...) =
         plot(t./u"fs" .|> NoUnits, y, args...; kwargs...)
     plot(t::AbstractVector{<:Unitful.Frequency}, y, args...; kwargs...) =
         plot(t./u"THz" .|> NoUnits, y, args...; kwargs...)

     plot(x::AbstractVector{<:Real}, E::AbstractVector{<:ElectricField}, args...; kwargs...) =
         plot(x, E./(u"V"/u"m") .|> NoUnits, args...; kwargs...)
   #+END_SRC

   #+RESULTS:

* Units
  #+BEGIN_SRC julia
    # Unit arithmetic is performed "outside" of @u_str, to ensure type
    # stability and allow precompilation
    base_units = Dict{Symbol,Unitful.FreeUnits}(
        :Œª => u"nm",
        :I‚ÇÄ => u"W"/u"cm"^2,
        :E‚ÇÄ => u"V"/u"m",
        :œÑ => u"fs",
        :œÉ => u"fs",
        :œÉ‚Ä≤ => u"fs",
        :œÉmax => NoUnits,
        :œÉ‚Ä≤max => NoUnits,
        :tmax => u"fs",
        :Tmax => NoUnits,
        :T => u"fs",
        :f => u"THz",
        :ŒΩ => u"cm"^-1,
        :œâ => u"Trad"/u"s",
        :ƒßœâ => u"eV",
        :U‚Çö => u"eV"
    )

    function get_unitful_quantity(field_params::Dict{Symbol,Any}, sym::Symbol)
        v = field_params[sym]
        typeof(v) <: Quantity || sym ‚àâ keys(base_units) ? v : v*base_units[sym]
    end

    function set_base_units(unit_specs::Dict{Symbol, Any})
        global base_units
        unknown_units = setdiff(keys(unit_specs),
                                keys(base_units))
        length(unknown_units) != 0 && error("Unknown base unit, $(join(unknown_units, ", "))")

        for (k,v) in unit_specs
            base_units[k] = v
        end

        nothing
    end

    macro set_base_units(spec)
        spec.head == :-> ||
            error("Expected a block with parameters for definition of the field")
        block = spec.args[2]
        block.head == :block ||
            error("Expected a block with parameters for definition of the field")

        set_base_units(parse_block(block, Any))
    end

    export @set_base_units

    usplit(u) = ustrip(u),unit(u)
  #+END_SRC

  #+RESULTS:
  : usplit (generic function with 1 method)

* DSLs
** Parse assignment DSL blocks
   #+BEGIN_SRC julia
     function parse_block(block, T)
         line_no = 0
         filename = ""
         error_message = v -> error("$(filename):$(line_no)\n>   $(v)")

         field_params = Dict{Symbol,T}()
         param_line_nos = Dict()

         for line in block.args
             if typeof(line) == LineNumberNode
                 line_no,filename = line.line,line.file
                 continue
             end
             typeof(line) == Expr || error_message("Expected expression, got $(line)")
             line.head == Symbol("=") ||
                 error_message("Expected ‚Äúparameter = value expression‚Äù, got $(line)")
             k = line.args[1]
             k in keys(field_params) &&
                 error_message("Field parameter $(k) already specified at $(filename):$(param_line_nos[k])")
             v = line.args[2]
             field_params[k] = eval(v)
             param_line_nos[k] = line_no
         end

         field_params
     end
   #+END_SRC

   #+RESULTS:
   : parse_block (generic function with 1 method)

** DSL for calculation of quantities
   The somewhat complicated setup with walking the expression tree in
   =make_field= (twice implemented :) allows for very clean expression
   of the formulaic dependencies between different quantities, almost
   as if it were pure math. All ingoing quantities are either unitful,
   or made unitful using the set base units. Furthermore, outgoing
   quantities are transformed to the base units, even though the
   expression may result in a different (but equivalent) unit
   expression. This way, even if a period time is provided in
   femtoseconds, the wavenumber will always be returned in Kaysers, for
   instance.

*** Testing presence of quantity in the namespace
    These methods are used for the =if x= constructs in the quantity
    conversion DSL. We return =true= if the symbol =x= is present in
    the =params= dict. Since we implement it as an expression walking
    algorithm, we can have constructs as =if x || y=, which will
    expand to =if :x in keys(params) || :y in keys(params)=. At first,
    however, we check if the symbols =isdefined= in the =Main= scope,
    which is generally the case for operators and such, to avoid
    generating tentative key lookups for every symbol that is
    encountered.
    #+BEGIN_SRC julia
      test_symbol_walk(node, params) = node
      test_symbol_walk(node::Symbol, params) =
          isdefined(Main, node) ? node : Expr(:call, :in, Expr(:quote, node),
                                              Expr(:call, :keys, params))
      test_symbol_walk(node::Expr, params) =
          Expr(node.head, test_symbol_walk.(node.args, Ref(params))...)
    #+END_SRC

    #+RESULTS:
    : test_symbol_walk (generic function with 3 methods)

*** Expression walker
    This walks the quantity conversions block, replacing symbols with
    references to dictionary items and converting quantities to
    applicable base units, before assignment. As above, before
    generating dictionary lookups for all symbols encountered, we
    first check if the symbol =isdefined= in the =Main= scope.
    #+BEGIN_SRC julia
      get_reference(r::Symbol,params) = Expr(:ref, params, Expr(:quote, r))
      get_reference(r,params) = r

      function get_symbol(s::Symbol, params, escape)
          if isdefined(Main, s)
              escape ? esc(s) : s
          else
              test_expression = test_symbol_walk(s, params)
              ref_expression = get_reference(s, params)
              Expr(:if, test_expression, ref_expression, escape ? esc(s) : s)
          end
      end
      get_symbol(s, params, escape) = s

      walk(node, params, escape) = node
      walk(node::Symbol, params, escape) = get_symbol(node, params, escape)

      function walk(node::Expr, params, escape)
          if node.head ‚àà [:line, :quote, :macrocall]
              node
          elseif node.head ‚àà [:if, :elseif]
              # Dispatch "if x" to test_symbol_walk, which checks if :x is
              # present as key in params.
              args = Any[test_symbol_walk(node.args[1], params)]
              append!(args, [walk(a, params, escape) for a in node.args[2:end]])
              Expr(node.head, args...)
          else
              if node.head == :(=)
                  target,expr = node.args
                  r = get_reference(target, params)
                  result = walk(expr, params, escape)
                  if typeof(target) == Symbol && target ‚àà keys(base_units)
                      # Generate expression that converts to the correct
                      # base unit.
                      result = Expr(:call, :|>, result,
                                    Expr(:ref, base_units,
                                         Expr(:quote, target)))
                  end
                  Expr(node.head, r, result)
              else
                  args = walk.(node.args, Ref(params), Ref(escape))
                  Expr(node.head, args...)
              end
          end
      end
    #+END_SRC

    #+RESULTS:
    : walk (generic function with 3 methods)

*** Namespace macro
    This macro uses the dictionary =params= as a "namespace", i.e. all
    symbols are assumed to be keys in this dictionary. We need to
    escape the generated expression tree to modify in the scope of the
    caller, not the global scope.
    #+BEGIN_SRC julia
      macro namespace!(exprs, params)
          local tree = walk(exprs, params, false)
          quote
              $(esc(tree))()
          end
      end
    #+END_SRC

    #+RESULTS:
    : @namespace! (macro with 1 method)

**** TEST
     #+BEGIN_SRC julia
       import ElectricFields: @namespace!
     #+END_SRC

**** TEST Namespace macro
     #+BEGIN_SRC julia
       params = Dict{Symbol,Rational}()

       @namespace!(params) do
           x = 5
           y = 3x
           z = x//3
           if x
               w = x^2
           end
       end

       @test params[:x] == 5
       @test params[:y] == 15
       @test params[:z] == 5//3
       @test params[:w] == 25

       params2 = Dict{Symbol,Quantity}(:Œª => 1u"m")

       @namespace!(params2) do
           if Œª
               ŒΩ = 1/Œª
           end
       end

       @test params2[:ŒΩ] == 1u"m"^-1

       params3 = Dict{Symbol,Rational}()

       factor = 4
       @namespace!(params3) do
           x = 5
           y = factor*x
       end

       @test params3[:y] == 20

       for i in 1:8
           params4 = Dict{Symbol,Rational}()
           @namespace!(params4) do
               x = 5
               y = i*x
           end

           @test params4[:y] == 5i
       end
     #+END_SRC

     #+RESULTS:
     : nothing

*** Test of "competing quantities"
    This function ensures that one and only one of "competing"
    quantities is specified.
    #+BEGIN_SRC julia
      function test_field_parameters(field_params, set)
          info = set ‚à© keys(field_params)
          set_string = join(set, ", ", " and ")

          length(info) == 0 &&
              (length(set) > 1 && error("Need to provide one of $(set_string)") ||
               error("Required parameter $(set_string) missing"))
          length(info) > 1 &&
              error("Can only specify one of $(set_string)")

          info
      end
    #+END_SRC

    #+RESULTS:
    : test_field_parameters (generic function with 1 method)

* Field types
  #+BEGIN_SRC julia
    abstract type AbstractField end
    abstract type AbstractCarrier end
    abstract type AbstractEnvelope end

    # # Not possible in current version of Julia
    # # https://github.com/JuliaLang/julia/issues/14919
    # (f::AbstractField)(t::Number) = envelope(f)(t)*carrier(f)(t)

    wavelength(f::AbstractField) = wavelength(carrier(f))
    period(f::AbstractField) = period(carrier(f))

    frequency(f::AbstractField) = frequency(carrier(f)) |> base_units[:f]
    max_frequency(f::AbstractField) = max_frequency(carrier(f)) |> base_units[:f]
    wavenumber(f::AbstractField) = wavenumber(carrier(f))
    fundamental(f::AbstractField) = fundamental(carrier(f))
    energy(f::AbstractField) = energy(carrier(f)) |> base_units[:ƒßœâ]


    intensity(f::AbstractField) = intensity(envelope(f))
    amplitude(f::AbstractField) = amplitude(envelope(f))
    duration(f::AbstractField) = duration(envelope(f))
    continuity(f::AbstractField) = continuity(envelope(f))
  #+END_SRC

  #+RESULTS:
  : continuity (generic function with 1 method)
** Linear field
   #+BEGIN_SRC julia
     struct LinearField <: AbstractField
         carrier::AbstractCarrier
         env::AbstractEnvelope # Amplitude envelope
         params::Dict{Symbol, Any}
     end

     (f::LinearField)(t::Unitful.Time) = f.carrier(t)*f.env(t)
     (f::LinearField)(fs::Unitful.Frequency=default_sampling_frequency(f)) = f(timeaxis(f, fs))

     function show(io::IO, f::LinearField)
         write(io, "Linearly polarized field with\n  ‚Äì a ")
         show(io, f.carrier)
         write(io, " \n  ‚Äì and a ")
         show(io, f.env)
     end

     carrier(f::LinearField) = f.carrier
     envelope(f::LinearField) = f.env
     params(f::LinearField) = f.params
   #+END_SRC

   #+RESULTS:
   : envelope (generic function with 1 method)

** Transverse field
   #+BEGIN_SRC julia
     struct TransverseField <: AbstractField
         z::LinearField
         x::LinearField
     end

     duration(f::TransverseField) = max(duration.((f.z,f.x))...)
   #+END_SRC

   #+RESULTS:
   : duration (generic function with 2 methods)

** Keldysh parameter
   The [[https://en.wikipedia.org/wiki/Tunnel_ionization][Keldysh parameter]] relates the strength of a dynamic electric
   field to that of the binding potential of an atom. It is given by

   \[\gamma = \sqrt{\frac{I_p}{2U_p}},\]

   where \(I_p\) is the ionization potential of the atom and \(U_p\)
   is the ponderomotive potential of the dynamic field.
   #+BEGIN_SRC julia
     keldysh(f::AbstractField, I‚Çö::Unitful.Energy) = ‚àö(I‚Çö/2params(f)[:U‚Çö]) |> NoUnits
   #+END_SRC

   #+RESULTS:
   : keldysh (generic function with 1 method)

** Exports
   #+BEGIN_SRC julia
     export carrier,
         wavelength, period,
         frequency, max_frequency, wavenumber, fundamental, energy,
         envelope,
         intensity, amplitude,
         duration,
         params,
         keldysh
   #+END_SRC

   #+RESULTS:
   : nothing

* Time axis
  We construct the time axis such that the highest frequency component
  of the field is resolved. By the Nyquist sampling theorem, we need
  minimum \(f_s>2f_{\textrm{max}}\), but to be on the safe side, we
  use, as default, \(f_s=100f_{\textrm{max}}\). This also makes plots
  nicer.
  #+BEGIN_SRC julia
    span(f::AbstractField) = span(envelope(f))

    const DEFAULT_SAMPLING_FACTOR = 100
    default_sampling_frequency(f::AbstractField) = DEFAULT_SAMPLING_FACTOR*max_frequency(f)

    steps(f::AbstractField, fs::Unitful.Frequency=default_sampling_frequency(f)) =
        ceil(Int, fs*abs(-(span(f)...)))
    steps(f::AbstractField, ndt::Integer) = steps(f, ndt/period(f))

    function timeaxis(f::AbstractField, fs::Unitful.Frequency=default_sampling_frequency(f))
        a,b = span(f)
        range(a, stop=b, length=steps(f, fs))
    end
    timeaxis(f::AbstractField, ndt::Integer) = timeaxis(f, ndt/period(f))

    export span, steps, timeaxis
  #+END_SRC

  #+RESULTS:
  : nothing

* Carriers
  #+BEGIN_SRC julia :results value verbatim
    carrier_types = Dict{Symbol,Any}()

    max_frequency(carrier::AbstractCarrier) = frequency(carrier)
  #+END_SRC

  #+RESULTS:
  : max_frequency (generic function with 2 methods)

** Fixed carrier
   The carrier is fixed in the sense that the instantaneous frequency
   is constant throughout the pulse.
   #+BEGIN_SRC julia
     struct FixedCarrier <: AbstractCarrier
         Œª::Unitful.Length
         T::Unitful.Time
         œâ::Unitful.Frequency
         œï::Number # Carrier‚Äìenvelope phase, in radians
     end

     (carrier::FixedCarrier)(t::Unitful.Time) = sin(carrier.œâ*t + carrier.œï)

     carrier_types[:fixed] = FixedCarrier

     wavelength(carrier::FixedCarrier) = carrier.Œª
     period(carrier::FixedCarrier) = carrier.T

     frequency(carrier::FixedCarrier) = 1/carrier.T
     wavenumber(carrier::FixedCarrier) = 1/carrier.Œª
     fundamental(carrier::FixedCarrier) = carrier.œâ
     energy(carrier::FixedCarrier) = carrier.œâ * u"ƒß" |> base_units[:ƒßœâ]

     function FixedCarrier(field_params::Dict{Symbol,Any})
         @unpack Œª, T, œâ = field_params
         œï = get(field_params, :œï, 0)
         FixedCarrier(Œª, T, œâ, œï)
     end

     function show(io::IO, carrier::FixedCarrier)
         write(io, @sprintf("Fixed carrier @ Œª = %0.2f %s (T = %0.2f %s)",
                            usplit(carrier.Œª)..., usplit(carrier.T)...))
         if carrier.œï != 0
             write(io, @sprintf("; CEP = %0.2fœÄ", carrier.œï/œÄ))
         end
     end
   #+END_SRC

   #+RESULTS:
   : show (generic function with 311 methods)

** Harmonic carrier
   #+BEGIN_SRC julia
     struct HarmonicCarrier <: AbstractCarrier
         Œª::Unitful.Length
         T::Unitful.Time
         œâ::Unitful.Frequency
         œï::Number # Carrier‚Äìenvelope phase, in radians
         q::AbstractVector{Int}
     end

     harmonics(carrier::HarmonicCarrier) = carrier.q
     export harmonics

     (carrier::HarmonicCarrier)(t::Unitful.Time) = sum(sin(q*(carrier.œâ*t + carrier.œï))
                                                       for q ‚àà harmonics(carrier))

     carrier_types[:harmonic] = HarmonicCarrier

     wavelength(carrier::HarmonicCarrier) = carrier.Œª
     period(carrier::HarmonicCarrier) = carrier.T

     frequency(carrier::HarmonicCarrier) = 1/carrier.T
     max_frequency(carrier::HarmonicCarrier) = maximum(harmonics(carrier))*frequency(carrier)
     wavenumber(carrier::HarmonicCarrier) = 1/carrier.Œª
     fundamental(carrier::HarmonicCarrier) = carrier.œâ
     energy(carrier::HarmonicCarrier) = carrier.œâ * u"ƒß" |> base_units[:ƒßœâ]

     function HarmonicCarrier(field_params::Dict{Symbol,Any})
         @unpack Œª, T, œâ, q = field_params
         œï = get(field_params, :œï, 0)
         HarmonicCarrier(Œª, T, œâ, œï, q)
     end

     function show(io::IO, carrier::HarmonicCarrier)
         write(io, @sprintf("Harmonic carrier @ Œª = %0.2f %s (T = %0.2f %s); q ‚àà %s",
                            usplit(carrier.Œª)..., usplit(carrier.T)...,
                            string(harmonics(carrier))))
         if carrier.œï != 0
             write(io, @sprintf("; CEP = %0.2fœÄ", carrier.œï/œÄ))
         end
     end
   #+END_SRC

   #+RESULTS:
   : show (generic function with 312 methods)

** Dispersed carriers [0/2]
*** TODO Chirped carrier
*** TODO Sellmeier equations
** Constant carrier
   The carrier is constant in the sense that wavelength is infinite
   and there is no oscillation, but the type still fulfils the carrier
   interface, such that it can be used to establish a time-base, etc.
   #+BEGIN_SRC julia
     struct ConstantCarrier <: AbstractCarrier
         Œª::Unitful.Length
         T::Unitful.Time
         œâ::Unitful.Frequency
     end

     (carrier::ConstantCarrier)(t::Unitful.Time) = 1

     carrier_types[:constant] = ConstantCarrier

     wavelength(carrier::ConstantCarrier) = carrier.Œª
     period(carrier::ConstantCarrier) = carrier.T

     frequency(carrier::ConstantCarrier) = 1/carrier.T
     wavenumber(carrier::ConstantCarrier) = 1/carrier.Œª
     fundamental(carrier::ConstantCarrier) = carrier.œâ
     energy(carrier::ConstantCarrier) = carrier.œâ * u"ƒß" |> base_units[:ƒßœâ]

     function ConstantCarrier(field_params::Dict{Symbol,Any})
         @unpack Œª, T, œâ = field_params
         ConstantCarrier(Œª, T, œâ)
     end

     function show(io::IO, carrier::ConstantCarrier)
         write(io, @sprintf("Constant carrier @ Œª = %0.2f %s (T = %0.2f %s)",
                            usplit(carrier.Œª)..., usplit(carrier.T)...))
     end
   #+END_SRC
* TODO Envelopes [2/3]
  The envelopes implemented below are all /amplitude/ envelopes,
  since that is what is being used in calculations. However, they may
  be specified using intensity-related quantities, e.g. Gaussian
  pulses are most often specified using the FWHM duration of their
  /intensity/ envelopes.

  #+BEGIN_SRC julia :results value verbatim
    envelope_types = Dict{Symbol,Any}()
  #+END_SRC

  #+RESULTS:
  : Dict{Symbol,Any} with 0 entries

** DONE Gaussian
   A Gaussian pulse is given by

   \[I_0\exp\left(-\frac{t^2}{2\sigma^2}\right),\]

   where the standard deviation œÉ is related to the FWHM duration œÑ
   of the intensity envelope as

   \[\sigma = \frac{\tau}{2\sqrt{2\ln 2}}.\]

   Furthermore, the /amplitude/ standard deviation œÉ‚Ä≤ is proportional
   to the intensity ditto: \(\sigma' = \sqrt{2}\sigma\). Therefore,
   the amplitude envelope is given by

   \[E_0\exp\left(-\frac{t^2}{2{\sigma'}^2}\right)
   =E_0\exp\left(-\frac{t^2}{4\sigma^2}\right)
   =E_0\exp\left(-\frac{2\ln2t^2}{\tau^2}\right).\]

   Since a Gaussian never ends, we specify how many œÉ we
   require; the resulting time window will be rounded up to an
   integer amount of cycles of the fundamental.

   #+BEGIN_SRC julia
     struct GaussianEnvelope <: AbstractEnvelope
         œÑ::Number # Intensity FWHM
         œÉ::Number # Intensity std.dev.
         œÉ‚Ä≤::Number # Envelope std.dev.
         œÉmax::Number
         œÉ‚Ä≤max::Number
         tmax::Number # Maximum time. Time window: [-tmax,tmax]
         Tmax::Integer # Maximum time, in cycles of the fundamental.
         I‚ÇÄ::Number
         E‚ÇÄ::Number
     end
     envelope_types[:gauss] = GaussianEnvelope

     (env::GaussianEnvelope)(t::Unitful.Time) = env.E‚ÇÄ*exp(-t^2/(2*env.œÉ‚Ä≤^2))

     show(io::IO, env::GaussianEnvelope) =
         write(io, @sprintf("I‚ÇÄ = %0.2g %s Gaussian envelope of duration %0.2g %s (intensity FWHM; ¬±%0.2fœÉ) ",
                            usplit(env.I‚ÇÄ)..., usplit(env.œÑ)..., env.œÉmax))

     function GaussianEnvelope(field_params::Dict{Symbol,Any})
         test_field_parameters(field_params, [:T]) # Period time required to round time window up
         test_field_parameters(field_params, [:œÑ, :œÉ, :œÉ‚Ä≤])
         test_field_parameters(field_params, [:œÉmax, :œÉ‚Ä≤max, :tmax, :Tmax])

         @namespace!(field_params) do
             if œÑ
                 œÉ = œÑ/(2*‚àö(2log(2)))
             else
                 if œÉ‚Ä≤
                     œÉ = œÉ‚Ä≤/‚àö2
                 end
                 œÑ = 2*‚àö(2log(2))*œÉ
             end
             if !œÉ‚Ä≤
                 œÉ‚Ä≤ = ‚àö2*œÉ
             end

             if œÉmax || œÉ‚Ä≤max
                 if œÉmax
                     Tmax = ceil(Int, œÉmax*œÉ/T)
                 elseif œÉ‚Ä≤max
                     Tmax = ceil(Int, œÉ‚Ä≤max*œÉ‚Ä≤/T)
                 end
                 tmax = Tmax*T
             else
                 if tmax
                     Tmax = ceil(Int, tmax/T)
                 elseif Tmax
                     tmax = Tmax*T
                 end
             end
             œÉmax = tmax/œÉ
             œÉ‚Ä≤max = tmax/œÉ‚Ä≤
         end

         @unpack œÑ, œÉ, œÉ‚Ä≤, œÉmax, œÉ‚Ä≤max, tmax, Tmax, I‚ÇÄ, E‚ÇÄ = field_params
         GaussianEnvelope(œÑ, œÉ, œÉ‚Ä≤, œÉmax, œÉ‚Ä≤max, tmax, Tmax, I‚ÇÄ, E‚ÇÄ)
     end

     continuity(::GaussianEnvelope) = Inf
     span(env::GaussianEnvelope) = (-env.tmax, env.tmax)

     intensity(env::GaussianEnvelope) = env.I‚ÇÄ
     amplitude(env::GaussianEnvelope) = env.E‚ÇÄ
   #+END_SRC

   #+RESULTS:
   : span (generic function with 2 methods)

*** Spectrum
    Gaussians belong to the [[https://en.wikipedia.org/wiki/Schwartz_space][Schwarz class]], i.e. functions who, under Fourier
    transform, are mapped back to the same space. That is to say, the
    Fourier transform of a Gaussian is a Gaussian:

    \[\exp(-\alpha t^2) \leftrightarrow
    \frac{1}{\sqrt{2\alpha}}
    \exp\left(-\frac{\omega^2}{4\alpha}\right).\]

    Comparing with the above, we find that the spectral standard
    deviation

    \[\Omega = \sqrt{2\alpha} = \frac{2\sqrt{\ln 2}}{\tau},\]

    and the Gaussian function in the spectral domain is thus

    \[E(\omega) =
    \frac{E_0\tau}{2\sqrt{\ln 2}}
    \exp\left[-\frac{(\omega\tau)^2}{8\ln2}\right].\]

    #+BEGIN_SRC julia
      function spectrum(env::GaussianEnvelope)
          N = env.E‚ÇÄ*env.œÑ/(2*‚àö(log(2)))
          œâ -> N*exp(-(œâ*env.œÑ)^2/8log(2))
      end
    #+END_SRC

    #+RESULTS:
    : spectrum (generic function with 1 method)

** DONE Trapezoidal
   #+BEGIN_SRC julia
     struct TrapezoidalEnvelope <: AbstractEnvelope
         ramp_up::Number
         flat::Number
         ramp_down::Number
         I‚ÇÄ::Number
         E‚ÇÄ::Number
         T::Unitful.Time
     end
     envelope_types[:trapezoidal] = TrapezoidalEnvelope
     # Common alias
     envelope_types[:tophat] = TrapezoidalEnvelope

     function (env::TrapezoidalEnvelope)(t::Unitful.Time)
         t /= env.T
         f = if t < 0
             0
         elseif t < env.ramp_up
             t/env.ramp_up
         elseif t < env.ramp_up + env.flat
             1
         elseif t < env.ramp_up + env.flat + env.ramp_down
             1 - (t-env.ramp_up-env.flat)/env.ramp_down
         else
             0
         end
         f*env.E‚ÇÄ
     end

     show(io::IO, env::TrapezoidalEnvelope) =
         write(io, @sprintf("I‚ÇÄ = %0.2g %s /%s‚Äæ%s‚Äæ%s\\ cycles trapezoidal envelope",
                            usplit(env.I‚ÇÄ)...,
                            env.ramp_up, env.flat, env.ramp_down))

     function TrapezoidalEnvelope(field_params::Dict{Symbol,Any})
         test_field_parameters(field_params, [:T]) # Period time required to relate ramps/flat to cycles
         test_field_parameters(field_params, [:ramp, :ramp_up])
         test_field_parameters(field_params, [:ramp, :ramp_down])
         test_field_parameters(field_params, [:flat])

         @namespace!(field_params) do
             if ramp
                 ramp_up = ramp
                 ramp_down = ramp
             end
         end

         @unpack ramp_up, flat, ramp_down, I‚ÇÄ, E‚ÇÄ, T = field_params

         ramp_up >= 0 || error("Negative up-ramp not supported")
         flat >= 0 || error("Negative flat region not supported")
         ramp_down >= 0 || error("Negative down-ramp not supported")
         ramp_up + flat + ramp_down > 0 || error("Pulse length must be non-zero")

         TrapezoidalEnvelope(ramp_up, flat, ramp_down, I‚ÇÄ, E‚ÇÄ, T)
     end

     continuity(::TrapezoidalEnvelope) = 0
     span(env::TrapezoidalEnvelope) = (0u"fs", (env.ramp_up + env.flat + env.ramp_down)*env.T)

     intensity(env::TrapezoidalEnvelope) = env.I‚ÇÄ
     amplitude(env::TrapezoidalEnvelope) = env.E‚ÇÄ
   #+END_SRC

   #+RESULTS:
   : span (generic function with 3 methods)

** TODO Sin2

** CW
   #+BEGIN_SRC julia
     struct CWEnvelope <: AbstractEnvelope
         tmax::Number # Maximum time. Time window: [-tmax,tmax]
         Tmax::Integer # Maximum time, in cycles of the fundamental.
         I‚ÇÄ::Intensity
         E‚ÇÄ::ElectricField
     end
     envelope_types[:cw] = CWEnvelope

     (env::CWEnvelope)(t::Unitful.Time) = env.E‚ÇÄ

     show(io::IO, env::CWEnvelope) =
         write(io, @sprintf("I‚ÇÄ = %0.2g %s CW envelope of duration %0.2g %s (%0.2g cycles) ",
                            usplit(env.I‚ÇÄ)..., usplit(env.tmax)..., env.Tmax))

     function CWEnvelope(field_params::Dict{Symbol,Any})
         test_field_parameters(field_params, [:T]) # Period time required to set time window
         test_field_parameters(field_params, [:tmax, :Tmax])

         @namespace!(field_params) do
             if tmax
                 Tmax = ceil(Int, tmax/T)
             end
             tmax = Tmax*T
         end

         @unpack tmax, Tmax, I‚ÇÄ, E‚ÇÄ = field_params
         CWEnvelope(tmax, Tmax, I‚ÇÄ, E‚ÇÄ)
     end

     continuity(::CWEnvelope) = Inf
     span(env::CWEnvelope) = (0u"s", env.tmax)

     intensity(env::CWEnvelope) = env.I‚ÇÄ
     amplitude(env::CWEnvelope) = env.E‚ÇÄ
   #+END_SRC
** Exports
   #+BEGIN_SRC julia
     export continuity
   #+END_SRC

   #+RESULTS:
   : nothing

* Field arithmetic [1/1]
  For calculations, a time-base is necessary ("normalized time"), with
  respect to which all harmonic motions &c are analyzed.  When
  combining fields of commensurate frequencies, it is easy to
  establish a common time-base, most likely the fundamental wavelength
  will be the obvious choice -- such as when adding an IR field and its
  harmonic components as generated through e.g. HHG:

  \[E(t) = \sum_q E_{2q + 1}(t)\sin[(2q+1)\omega t].\]

  However, when adding incommensurate frequencies, there is no obvious
  choice, so the user has to specify the time-base explicitly -- maybe
  by the order in which the fields are added?

  There should also be some helper routines that, when discretizing
  the time axis, estimate whether all harmonic components of interest
  are satisfactorily resolved.

** Sum fields
   #+BEGIN_SRC julia
     import Base: +

     mutable struct SumField <: AbstractField
         a::AbstractField
         b::AbstractField
     end

     function show(io::IO, f::SumField)
         a_str = split(string(f.a), "\n")
         b_str = split(string(f.b), "\n")

         for (s,l) in zip("‚åà" * repeat("|", length(a_str)-1), a_str)
             write(io, "$s $l\n")
         end

         write(io, "‚äï\n")

         for (s,l) in zip(repeat("|", length(b_str)-1) * "‚åä", b_str)
             write(io, "$s $l\n")
         end
     end

     +(a::AbstractField,
       b::AbstractField) = SumField(a, b)

     (f::SumField)(t::Unitful.Time) = f.a(t) + f.b(t)
     (f::SumField)(fs::Unitful.Frequency=default_sampling_frequency(f)) = f.a(fs) + f.b(fs)

     function span(f::SumField)
         sa = span(f.a)
         sb = span(f.b)
         (min(sa[1], sb[1]), max(sa[2],sb[2]))
     end

     for fun in [:wavelength, :period, :frequency, :wavenumber, :fundamental, :energy]
         @eval begin
             function ($fun)(f::SumField)
                 a = ($fun)(f.a)
                 b = ($fun)(f.b)
                 a != b && error("$(ucfirst(string($fun))) differs between SumField composants!")
                 a
             end
         end
     end

     max_frequency(f::SumField) =
         max(max_frequency(f.a), max_frequency(f.b))

     continuity(f::SumField) =
         min(continuity(f.a), continuity(f.b))
   #+END_SRC

   #+RESULTS:
   : continuity (generic function with 5 methods)

** Negated fields
   #+BEGIN_SRC julia
     import Base: -

     mutable struct NegatedField <: AbstractField
         a::AbstractField
     end
     (f::NegatedField)(t::Unitful.Time) = -f.a(t)
     (f::NegatedField)(fs::Unitful.Frequency=default_sampling_frequency(f)) = -f.a(fs)

     -(a::AbstractField,
       b::AbstractField) = a + NegatedField(b)
     -(a::AbstractField) = NegatedField(a)

     mutable struct NegatedCarrier <: AbstractCarrier
         carrier::AbstractCarrier
     end
     (carrier::NegatedCarrier)(t::Unitful.Time) = -carrier.carrier(t)

     carrier(f::NegatedField) = NegatedCarrier(carrier(f.a), f.t‚ÇÄ)
     envelope(f::NegatedField) = envelope(f.a)
   #+END_SRC

   #+RESULTS:
   : envelope (generic function with 3 methods)

** Delayed fields
   #+BEGIN_SRC julia
     mutable struct DelayedField <: AbstractField
         a::AbstractField
         t‚ÇÄ::Number
     end
     (f::DelayedField)(t::Unitful.Time) = f.a(t-f.t‚ÇÄ)

     function show(io::IO, f::DelayedField)
         show(io, f.a)
         write(io, "\n  ‚Äì delayed by ")
         show(io, f.t‚ÇÄ)
     end

     mutable struct DelayedCarrier <: AbstractCarrier
         carrier::AbstractCarrier
         t‚ÇÄ::Number
     end
     (carrier::DelayedCarrier)(t::Unitful.Time) = carrier.carrier(t-carrier.t‚ÇÄ)

     mutable struct DelayedEnvelope <: AbstractEnvelope
         env::AbstractEnvelope
         t‚ÇÄ::Number
     end
     (envelope::DelayedEnvelope)(t::Unitful.Time) = envelope.env(t-envelope.t‚ÇÄ)

     carrier(f::DelayedField) = DelayedCarrier(carrier(f.a), f.t‚ÇÄ)
     envelope(f::DelayedField) = DelayedEnvelope(envelope(f.a), f.t‚ÇÄ)

     span(env::DelayedEnvelope) = span(env.env) .+ env.t‚ÇÄ

     for FieldType in [:NegatedField, :DelayedField]
         for fun in [:wavelength, :period, :frequency, :max_frequency,
                     :wavenumber, :fundamental, :energy,
                     :intensity, :amplitude, :duration, :continuity,
                     :span, :steps]
             @eval ($fun)(f::($FieldType)) = ($fun)(f.a)
         end
     end
   #+END_SRC

   #+RESULTS:
   : nothing

*** DONE Delay operators
    Convention for delayed fields: a field delayed by a /positive/
    time, comes /later/, i.e. we write \(f(t-\delta t)\).
    #+BEGIN_SRC julia
      delay(a::AbstractField, t‚ÇÄ::Unitful.Time) = DelayedField(a, t‚ÇÄ)
      delay(a::AbstractField, nT::Real) = delay(a, nT*period(a))
      delay(a::AbstractField, œï::Quantity{Float64, Unitful.Dimensions{()}}) = delay(a, œï/(2œÄ*u"rad"))

      delay(a::DelayedField) = a.t‚ÇÄ
      delay(a::AbstractField) = 0u"s"

      export delay
    #+END_SRC

    #+RESULTS:
    : nothing
* Field evaluation
  Here we provide a convenience routine to evaluating fields on a arbitrary time vector.
  #+BEGIN_SRC julia
    for FieldType in [:LinearField, :SumField, :NegatedField, :DelayedField]
        @eval (f::($FieldType))(t::AbstractVector{<:Unitful.Time}) = f.(t)
    end
  #+END_SRC

  #+RESULTS:
  : nothing

* Field creation
** Parameter calculation
   This function performs the calculation of different quantities from
   the information provided.

   The [[https://en.wikipedia.org/wiki/Ponderomotive_energy][ponderomotive potential]] U_p is the cycle-average quiver energy
   of a free electron in an electromagnetic field. It is given by

   \[U_p =
   \frac{e^2E_0^2}{4m\omega^2}=\frac{2e^2}{c\varepsilon_0m}\times\frac{I}{4\omega^2},
   \]

   or, in atomic units,

   \[U_p = \frac{I}{4\omega^2}.\]

   #+BEGIN_SRC julia
     function calc_params!(field_params::Dict{Symbol,Any})
         test_field_parameters(field_params, [:Œª, :T, :f, :ŒΩ, :œâ, :ƒßœâ])
         test_field_parameters(field_params, [:I‚ÇÄ, :E‚ÇÄ, :U‚Çö])

         for k in keys(field_params)
             field_params[k] = get_unitful_quantity(field_params, k)
         end

         @namespace!(field_params) do
             if Œª || T
                 if Œª
                     T = Œª/u"c"
                 elseif T
                     Œª = T*u"c"
                 end
                 ŒΩ = 1/Œª
                 f = 1/T
                 œâ = 2œÄ*u"rad"*f
                 ƒßœâ = u"ƒß"*œâ
             else # ‚àù Frequency specified
                 if f || ŒΩ
                     if f
                         ŒΩ = f/u"c"
                     elseif ŒΩ
                         f = ŒΩ*u"c"
                     end
                     œâ = 2œÄ*u"rad"*f
                 elseif œâ || ƒßœâ
                     if œâ
                         ƒßœâ = u"ƒß"*œâ
                     elseif ƒßœâ
                         œâ = ƒßœâ/u"ƒß"
                     end
                     f = œâ/(2œÄ*u"rad")
                     ŒΩ = f/u"c"
                 end
                 T = 1/f
                 Œª = 1/ŒΩ
             end

             if I‚ÇÄ || U‚Çö
                 if U‚Çö
                     I‚ÇÄ = U‚Çö / (2*u"q"^2/(u"c"*u"Œµ0"*u"me")) * 4œâ^2
                 end
                 E‚ÇÄ = ‚àö(2I‚ÇÄ/(u"Œµ0"*u"c"))
             elseif E‚ÇÄ
                 I‚ÇÄ = u"Œµ0"*u"c"/2*E‚ÇÄ^2
             end
             if !U‚Çö
                 U‚Çö = 2*u"q"^2/(u"c"*u"Œµ0"*u"me") * I‚ÇÄ/4œâ^2
             end
         end

         field_params
     end
   #+END_SRC

   #+RESULTS:
   : calc_params! (generic function with 1 method)

** Frontend macro
   #+BEGIN_SRC julia
     function make_field(field_params::Dict{Symbol,Any})
         calc_params!(field_params)

         # Maybe these two blocks can be implicitly deduced from the passed
         # parameters? E.g. if a chirp parameter is given, the carrier type
         # should autmatically be resolved as ChirpedCarrier. Similarly, if
         # ramp and flat are given, a trapezoidal pulse is requested.

         carrier_sym = get(field_params, :carrier,
                           :q ‚àâ keys(field_params) ? :fixed : :harmonic)
         carrier_sym ‚àâ keys(carrier_types) &&
             error("Unknown carrier type $(carrier_sym), valid choices are $(keys(carrier_types))")
         :q ‚àà keys(field_params) && carrier_sym != :harmonic &&
             error("Invalid carrier type, $(carrier_sym), for field with harmonic components")
         carrier = carrier_types[carrier_sym](field_params)

         env_sym = get(field_params, :env, :gauss)
         env_sym ‚àâ keys(envelope_types) &&
             error("Unknown envelope type $(env_sym), valid choices are $(keys(envelope_types))")
         env = envelope_types[env_sym](field_params)

         :Œæ in keys(field_params) &&
             error("Elliptical (transverse) fields not yet supported!")

         LinearField(carrier, env, field_params)
     end

     macro field(spec, var)
         spec.head == :-> ||
             error("Expected a block with parameters for definition of the field")
         block = spec.args[2]
         block.head == :block ||
             error("Expected a block with parameters for definition of the field")

         local field_params = Dict{Symbol,Any}()
         local tree = walk(spec, field_params, true)
         quote
             $(tree)()
             $(esc(var)) = make_field($field_params)
         end
     end

     export @field
   #+END_SRC

   #+RESULTS:
   : nothing

** EXAMPLE Usage
*** Plot setup
    #+BEGIN_SRC julia
      plot(f::AbstractField, args...; kwargs...) = plot(timeaxis(f), f(), args...; kwargs...)
    #+END_SRC

    #+RESULTS:
    : plot (generic function with 5 methods)

*** Specifying wavelength
    A [[https://en.wikipedia.org/wiki/Gaussian_function][Gaussian envelope]] is the default and can be omitted; œÑ refers
    the [[https://en.wikipedia.org/wiki/Full_width_at_half_maximum][FWHM]] duration of the intensity envelope.
    #+BEGIN_SRC julia :exports both :results value verbatim
      @field(IR) do
          Œª  = 800.0
          I‚ÇÄ = 1e14
          œÑ  = 6.2
          Tmax = 10
          env = :gauss
      end
    #+END_SRC

    #+RESULTS:
    : Linearly polarized field with
    :   ‚Äì a Fixed carrier @ Œª = 800.00 nm (T = 2.67 fs) 
    :   ‚Äì and a I‚ÇÄ = 1e+14 cm^-2 W Gaussian envelope of duration 6.2 fs (intensity FWHM; ¬±10.14œÉ) 

    We can define a second pulse with the same parameters as the above,
    but with a carrier‚Äìenvelope phase of œÄ/2:

    #+BEGIN_SRC julia :exports both :results value verbatim
      @field(IR2) do
          Œª    = 800.0
          I‚ÇÄ   = 1e14
          œÑ    = 6.2
          Tmax = 10
          œï    = œÄ/2
      end
    #+END_SRC

    #+RESULTS:
    : Linearly polarized field with
    :   ‚Äì a Fixed carrier @ Œª = 800.00 nm (T = 2.67 fs); CEP = 0.50œÄ 
    :   ‚Äì and a I‚ÇÄ = 1e+14 cm^-2 W Gaussian envelope of duration 6.2 fs (intensity FWHM; ¬±10.14œÉ) 

    #+BEGIN_SRC julia :exports code
      t = timeaxis(IR)
      E = IR.(t)
      E2 = IR2.(t)
    #+END_SRC

    #+RESULTS:

    #+BEGIN_SRC julia :exports results :results value file
      figure("pulse")
      clf()
      plot(t./u"fs", IR.(t)./1e10u"V/m")
      plot(t./u"fs", IR2.(t)./1e10u"V/m")
      xlabel(L"$t$ [fs]")
      ylabel(L"$E$ [$10^{10}$ V/m]")
      tight_layout()
      savefig_f("ir")
    #+END_SRC

    #+RESULTS:
    [[file:../images/ir.svg]]
     
*** Trapezoidal envelope
    A trapezoidal envelope (also known as a tophat pulse; commonly
    used in calculations) has a ramp-up, a flat region, and a
    ramp-down.
    #+BEGIN_SRC julia :exports both :results value verbatim
      @field(XUV) do
          Œª    = 800.0u"nm"
          I‚ÇÄ   = 1e10u"W/cm^2"
          q    = 17:2:55 # Harmonic orders of 800 nm
          env  = :trapezoidal
          ramp = 5
          flat = 10
      end
    #+END_SRC

    #+RESULTS:
    : Linearly polarized field with
    :   ‚Äì a Harmonic carrier @ Œª = 800.00 nm (T = 2.67 fs); q ‚àà 17:2:55 
    :   ‚Äì and a I‚ÇÄ = 1e+10 cm^-2 W /5‚Äæ10‚Äæ5\ cycles trapezoidal envelope

    #+BEGIN_SRC julia :exports results :results value file
      t = timeaxis(XUV)

      figure("trapezoidal xuv")
      clf()
      plot(t./u"fs", NoUnits.(XUV.(t)./1e8u"V/m"))
      xlabel(L"$t$ [fs]")
      ylabel(L"$E$ [$10^8$ V/m]")
      margins(0.1,0.1)
      tight_layout()
      savefig_f("trapezoidal-xuv")
    #+END_SRC

    #+RESULTS:
    [[file:../images/trapezoidal-xuv.svg]]

*** Specifying period time, other base units
    #+BEGIN_SRC julia :exports both :results value verbatim
      @set_base_units() do
          Œª  = u"km"
      end

      @field(radio) do
          T     = 3.0u"ms"
          E‚ÇÄ    = 5u"V/m"
          œÑ     = 10u"s"
          œÉ‚Ä≤max = 5
      end
    #+END_SRC

    #+RESULTS:
    : Linearly polarized field with
    :   ‚Äì a Fixed carrier @ Œª = 899.38 km (T = 3.00 ms) 
    :   ‚Äì and a I‚ÇÄ = 3.3e-06 cm^-2 W Gaussian envelope of duration 10 s (intensity FWHM; ¬±7.07œÉ) 

*** Summing two fields
    #+BEGIN_SRC julia :exports both :results verbatim
      @set_base_units() do
          Œª  = u"nm"
      end

      @field(IR) do
          Œª  = 800.0
          E‚ÇÄ = 4
          œÑ  = 15u"fs"
          œÉmax = 5
          env = :gauss
      end

      @field(XUV) do
          Œª  = 800.0
          E‚ÇÄ = 1
          œÑ  = 2u"fs"
          œÉmax = 5
          env = :gauss
          q = 15:2:37
      end

      IR = delay(IR, 8u"fs")
      field = IR + XUV
    #+END_SRC

    #+RESULTS:
    : ‚åà Linearly polarized field with
    : |   ‚Äì a Fixed carrier @ Œª = 800.00 nm (T = 2.67 fs) 
    : |   ‚Äì and a I‚ÇÄ = 2.1e-06 cm^-2 W Gaussian envelope of duration 15 fs (intensity FWHM; ¬±5.03œÉ) 
    : |   ‚Äì delayed by 8 fs
    : ‚äï
    : | Linearly polarized field with
    : |   ‚Äì a Harmonic carrier @ Œª = 800.00 nm (T = 2.67 fs); q ‚àà 15:2:37 
    : ‚åä   ‚Äì and a I‚ÇÄ = 1.3e-07 cm^-2 W Gaussian envelope of duration 2 fs (intensity FWHM; ¬±6.28œÉ) 

    #+BEGIN_SRC julia :exports results :results value file
      t = timeaxis(field)

      figure("summed fields")
      clf()
      plot(t./u"fs" .|> NoUnits, field.(t)./u"V/m" .|> NoUnits, label="Combined field")
      plot(t./u"fs" .|> NoUnits, envelope(IR).(t)./u"V/m" .|> NoUnits, label="IR envelope")
      plot(t./u"fs" .|> NoUnits, envelope(XUV).(t)./u"V/m" .|> NoUnits, label="XUV envelope")
      legend()
      xlabel(L"$t$ [fs]")
      ylabel(L"$E$ [V/m]")
      margins(0.1,0.1)
      tight_layout()
      savefig_f("summed-fields")
    #+END_SRC

    #+RESULTS:
    [[file:../images/summed-fields.svg]]

** TEST Parametric field creation
   Test parametric creation of fields, both from inside a function and
   from global scope.
   #+BEGIN_SRC julia
     function test_parametric_fields(l)
         Is = range(0u"W/cm^2",stop=1e6u"W/cm^2", length=l)

         for (i,I‚ÇÄ) in enumerate(Is)
             @eval @field(IR) do
                 Œª = 800.0u"nm"
                 I‚ÇÄ = $(I‚ÇÄ)
                 œÑ = 6.2u"fs"
                 Tmax = 5
             end
             @test intensity(IR) == I‚ÇÄ
         end
     end
     test_parametric_fields(11)
     test_parametric_fields(8)

     Is = range(0u"W/cm^2",stop=1e6u"W/cm^2", length=11)

     for (i,I‚ÇÄ) in enumerate(Is)
         @eval @field(IR) do
             Œª = 800.0u"nm"
             I‚ÇÄ = $(I‚ÇÄ)
             œÑ = 6.2u"fs"
             Tmax = 5
         end
         @test intensity(IR) == I‚ÇÄ
     end
   #+END_SRC

* COMMENT Spectra
  We implement the calculation of the spectrum of /an arbitrary/ field
  using the FFT, which requires equidistant samples. For this reason,
  we only allow the evaluation of the spectrum on equidistant
  frequency vectors, which we ensure by only accepting =Range=
  objects.

  #+BEGIN_SRC julia
    import FFTW: fft
    function fft(f::AbstractField,
                 fs::Unitful.Frequency=default_sampling_frequency(f))
        t = timeaxis(f, fs)
        f_v = f(t)./(u"V"*u"m") .|> NoUnits
        fft(f_v)
    end
    spectrum(f::AbstractField,
             fs::Unitful.Frequency=default_sampling_frequency(f)) =
                 fftshift(fft(f,fs))*‚àö(2/œÄ)/NoUnits(fs*period(f))
  #+END_SRC

  #+RESULTS:
  : spectrum (generic function with 3 methods)

** Frequency axis
   #+BEGIN_SRC julia
     import DSP: fftfreq

     fftfreq(f::AbstractField, fs::Unitful.Frequency=default_sampling_frequency(f)) =
         fftfreq(steps(f, fs), fs/u"Hz" |> NoUnits)*u"Hz"

     freqaxis(f::AbstractField, fs::Unitful.Frequency=default_sampling_frequency(f)) =
         fftshift(fftfreq(f, fs))
   #+END_SRC

   #+RESULTS:
   : freqaxis (generic function with 2 methods)

** EXAMPLE Plot spectra
   #+BEGIN_SRC julia :exports both :results file
     @set_base_units() do
         Œª  = u"nm"
     end

     @field(IR) do
         Œª  = 800.0
         # I‚ÇÄ = 1e14
         E‚ÇÄ = 1
         œÑ  = 10u"fs"
         œÉmax = 25
         env = :gauss
     end

     @field(XUV) do
         Œª  = 800.0
         # I‚ÇÄ = 1e14
         E‚ÇÄ = 1
         œÑ  = 2u"fs"
         œÉmax = 5
         env = :gauss
         q = 15:2:37
     end

     XUV = delay(XUV, 8u"fs")
     field = IR + XUV


     t = timeaxis(field)

     f = freqaxis(field)
     sel = (f .>= 0u"Hz") .& (f .< 2max_frequency(field))
     F = spectrum(field)[sel]

     using PyPlot
     using Jagot.plotting
     plot_style("default")
     using DSP

     figure("field spectrum")
     clf()
     subplot(211)
     plot(t./u"fs" .|> NoUnits, field.(t)./u"V/m" .|> NoUnits, label="Combined field")
     plot(t./u"fs" .|> NoUnits, envelope(IR).(t)./u"V/m" .|> NoUnits, label="IR envelope")
     plot(t./u"fs" .|> NoUnits, envelope(XUV).(t)./u"V/m" .|> NoUnits, label="XUV envelope")
     legend()
     xlabel(L"$t$ [fs]")
     axes_labels_opposite(:x)
     subplot(212)
     plot(f[sel]./u"THz" .|> NoUnits,
          abs2.(F), label="Combined spectrum")
     plot(f[sel]./u"THz" .|> NoUnits,
          abs2.(spectrum(envelope(IR)).(2œÄ*(f[sel]-frequency(IR)))./(u"V*fs/m") .|> NoUnits),
          label="Analytic IR spectrum")
     margins(0, 0.1)
     yscale("log")
     xlim(0,2max_frequency(field)/u"THz")
     legend()
     xlabel(L"$f$ [THz]")
     # a2=gca()[:twinx]()
     # a2[:plot](f[sel]./u"THz" .|> NoUnits, unwrap(angle.(F)))
     tight_layout()
     savefig_f("spectrum")
   #+END_SRC

   #+RESULTS:
   [[file:../images/spectrum.svg]]
* Dispersed fields
  We calculate the effect of dispersion described by the Sellmeier
  equations in the frequency domain, to which we transform via an
  FFT. For this to be possible, we only allow the evaluation of the
  field for a specified sampling frequency, i.e. we don't provide an
  implementation for evaluating a =DispersedField= at an arbitrary
  time point.
  #+BEGIN_SRC julia
    using Sellmeier

    mutable struct DispersedField <: AbstractField
        a::AbstractField
        m::Medium
        d::Unitful.Length
    end

    function show(io::IO, f::DispersedField)
        show(io, f.a)
        write(io, "\n  ‚Äì dispersed through $(f.d) of $(f.m)")
    end

    disperse(a::AbstractField, m::Medium, d::Unitful.Length) =
        DispersedField(a, m, d)

    (f::DispersedField)(t::Union{Unitful.Time,AbstractVector{<:Unitful.Time}}) =
        error("Dispersed fields can only be evaluated by specifying a sampling frequency")

    function (f::DispersedField)(fs::Unitful.Frequency = default_sampling_frequency(f.a))
        FÃÇ = fft(f.a, fs)
        ifft(FÃÇ.*dispersion(f.m, f.d, fftfreq(f.a, fs), frequency(f.a)))*(u"V"*u"m")
    end

    max_frequency(f::DispersedField) = max_frequency(f.a)

    # This is, strictly speaking, not true, since dispersing a pulse will
    # in general stretch it in the time domain. It is up to the user to
    # ensure that the time window is large enough to contain even the
    # stretched pulse, by setting the œÉmax (or friends) to a large enough
    # value.
    span(f::DispersedField) = span(f.a)

    export disperse
  #+END_SRC

  #+RESULTS:
  : nothing

** EXAMPLE
   #+BEGIN_SRC julia :exports both :results verbatim
     using Sellmeier

     @field(IR) do
         Œª  = 800.0
         # I‚ÇÄ = 1e14
         E‚ÇÄ = 1
         œÑ  = 5u"fs"
         œÉmax = 30
         env = :gauss
     end

     IR = delay(IR, -20u"fs")
     dIR = disperse(IR, BK7, 800u"Œºm")

     IR + dIR
   #+END_SRC

   #+RESULTS:
   #+begin_example
   ‚åà Linearly polarized field with
   |   ‚Äì a Fixed carrier @ Œª = 800.00 nm (T = 2.67 fs) 
   |   ‚Äì and a I‚ÇÄ = 1.3e-07 cm^-2 W Gaussian envelope of duration 5 fs (intensity FWHM; ¬±30.16œÉ) 
   |   ‚Äì delayed by -20 fs
   ‚äï
   | Linearly polarized field with
   |   ‚Äì a Fixed carrier @ Œª = 800.00 nm (T = 2.67 fs) 
   |   ‚Äì and a I‚ÇÄ = 1.3e-07 cm^-2 W Gaussian envelope of duration 5 fs (intensity FWHM; ¬±30.16œÉ) 
   |   ‚Äì delayed by -20 fs
   ‚åä   ‚Äì dispersed through 800 Œºm of Medium([1.03961, 0.231792, 1.01047], [0.00600069867 Œºm^2, 0.0200179144 Œºm^2, 103.560653 Œºm^2])
   #+end_example

   #+BEGIN_SRC julia :exports results :results file
     figure("dispersion")
     clf()
     plot(IR+dIR, label="Sum")
     plot(IR-dIR, label="Difference")
     legend()
     xlabel(L"$t$ [fs]")
     title("IR & dispersed field")
     savefig_f("dispersion")
   #+END_SRC

   #+RESULTS:
   [[file:../images/dispersion.svg]]
