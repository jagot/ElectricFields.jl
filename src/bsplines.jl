# * Unit Vectors
"""
    UnitVector{T}(N, k)

Helper vector type of length `N` where the `k`th element is `one(T)`
and all the others `zero(T)`.
"""
struct UnitVector{T} <: AbstractVector{T}
    N::Int
    k::Int
end

Base.size(e::UnitVector) = (e.N,)
Base.getindex(e::UnitVector{T}, i::Int) where T = i == e.k ? one(T) : zero(T)
Base.show(io::IO, e::UnitVector{T}) where T = write(io, "ê{$T}($(e.k)|$(e.N))")

# * B-Splines

# This is a cannibalized version of the code found in CompactBases.jl,
# to avoid dragging in all dependencies.

"""
    BSpline(t, x, w, B, S)

Basis structure for the B-splines generated by the knot set `t`.
"""
struct BSpline{KnotSet<:AbstractKnotSet}
    t::KnotSet
end

# * Properties

function firstindex(B::BSpline, i)
    @assert i == 2
    1
end
function lastindex(B::BSpline, i)
    @assert i == 2
    numfunctions(B.t)
end
function size(B::BSpline, i)
    @assert i == 2
    numfunctions(B.t)
end

knotset(B::BSpline) = B.t
order(B::BSpline) = order(knotset(B))

function show(io::IO, B::BSpline)
    write(io, "BSpline basis with $(B.t)")
end

# # * Basis functions

"""
    deBoor(t, c, x[, i[, m=0]])

Evaluate the spline given by the knot set `t` and the set of control
points `c` at `x` using de Boor's algorithm. `i` is the index of the
knot interval containing `x`. If `m≠0`, calculate the `m`th derivative
at `x` instead.
"""
function deBoor(t::AbstractKnotSet, c::AbstractVector, x::Number,
                i=find_interval(t, x), m=0)
    T = promote_type(eltype(t), eltype(c), typeof(x))
    isnothing(i) && return zero(T)
    k = order(t)
    nc = length(c)
    k == 1 && return (nc < i || m > 0) ? zero(T) : c[i]

    α = [r > 0 && r ≤ nc ? T(c[r]) : zero(T)
         for r ∈ i-k+1:i]
    nt = length(t)
    nf = numfunctions(t)
    for j = 1:k-1
        for r = i:-1:max(i-k+j,1)
            jjj = r+k-j
            (jjj > nt || jjj < 1) && continue
            r′ = r - i + k
            r ≠ 1 && r′ == 1 && continue

            a = t[r+k-j]
            b = t[r]

            α[r′] = if j ≤ m
                (k-j)*if r == 1
                    -α[r′]
                elseif r == nf + j
                    α[r′-1]
                else
                    α[r′-1] - α[r′]
                end
            else
                if r == 1
                    (b-x)*α[r′]
                elseif r == nf + j
                    (x-a)*α[r′-1]
                else
                    ((x-a)*α[r′-1] + (b-x)*α[r′])
                end
            end
            α[r′] /= (b-a)
        end
    end

    α[end]
end

function getindex(B::BSpline, x::Real, j::Integer)
    T = promote_type(eltype(B.t), typeof(x))
    deBoor(B.t, UnitVector{T}(size(B,2), j),
           x, find_interval(B.t, x))
end

function getindex(B::BSpline, x::Real, sel::AbstractVector)
    T = promote_type(eltype(B.t), typeof(x))
    i = find_interval(B.t, x)
    χ = spzeros(T, length(sel))
    o = sel[1] - 1
    for j in sel
        χ[j-o] = deBoor(B.t, UnitVector{T}(size(B,2), j), x, i)
    end
    χ
end

function basis_function!(χ, B::BSpline, x::AbstractVector, j)
    T = promote_type(eltype(B.t), eltype(x))
    eⱼ = UnitVector{T}(size(B,2), j)
    for (is,k) ∈ within_support(x, B.t, j)
        for i in is
            χ[i] = deBoor(B.t, eⱼ, x[i], k)
        end
    end
end

function getindex(B::BSpline, x::AbstractVector, sel::AbstractVector)
    T = promote_type(eltype(B.t), eltype(x))
    χ = spzeros(T, length(x), length(sel))
    o = sel[1] - 1
    for j in sel
        basis_function!(view(χ, :, j-o), B, x, j)
    end
    χ
end

getindex(B::BSpline, x, ::Colon) =
    getindex(B, x, 1:size(B,2))

function derivative(B::BSpline, x::Real, j::Integer, m)
    T = promote_type(eltype(B.t), typeof(x))
    deBoor(B.t, UnitVector{T}(size(B,2), j),
           x, find_interval(B.t, x), m)
end

function derivative(B::BSpline, x::Real, sel::AbstractVector, m)
    T = promote_type(eltype(B.t), typeof(x))
    i = find_interval(B.t, x)
    χ = spzeros(T, length(sel))
    o = sel[1] - 1
    for j in sel
        χ[j-o] = deBoor(B.t, UnitVector{T}(size(B,2), j), x, i, m)
    end
    χ
end

function derivative_basis_function!(χ, B::BSpline, x::AbstractVector, j, m)
    T = promote_type(eltype(B.t), eltype(x))
    eⱼ = UnitVector{T}(size(B,2), j)
    for (is,k) ∈ within_support(x, B.t, j)
        for i in is
            χ[i] = deBoor(B.t, eⱼ, x[i], k, m)
        end
    end
end

function derivative(B::BSpline, x::AbstractVector, sel::AbstractVector, m)
    T = promote_type(eltype(B.t), eltype(x))
    χ = spzeros(T, length(x), length(sel))
    o = sel[1] - 1
    for j in sel
        derivative_basis_function!(view(χ, :, j-o), B, x, j, m)
    end
    χ
end

derivative(B::BSpline, x, ::Colon, m) =
    derivative(B, x, 1:size(B,2), m)

struct BSplineView{Bt,Sel}
    B::Bt
    sel::Sel
end

knotset(B::BSplineView) = knotset(B.B)

function size(B::BSplineView, i)
    @assert i == 2
    length(B.sel)
end

function Base.show(io::IO, B::BSplineView)
    write(io, "Restriction to basis functions ")
    show(io, B.sel)
    write(io, " of ")
    show(io, B.B)
end

function getindex(B::BSpline, ::Colon, sel::AbstractVector)
    all(∈(1:size(B,2)), sel) ||
    throw(ArgumentError("Invalid selection"))
    BSplineView(B, sel)
end

getindex(B::BSplineView, x, j) =
    getindex(B.B, x, B.sel[j])

derivative(B::BSplineView, x, j, m) =
    derivative(B.B, x, B.sel[j], m)

const BSplineOrView = Union{BSpline,BSplineView}

# * Function interpolation

interpolate(B::BSplineOrView, x::AbstractVector, y::AbstractVector) =
    B[x,:] \ y

function interpolate(B::BSplineOrView, x::AbstractVector, y::AbstractMatrix)
    T = promote_type(eltype(knotset(B)), eltype(x), eltype(y))
    n = size(y,2)
    C = zeros(T, size(B,2), n)
    V = B[x,:]
    for j = 1:n
        C[:,j] = V \ y[:,j]
    end
    C
end
